#!/usr/bin/python3

import argparse
import asyncio
import json
import statistics
import sys
import threading
from collections import deque
from typing import NamedTuple

from pyeep.jackmidi import MidiPlayer

# See:
# https://soundprogramming.net/file-formats/general-midi-instrument-list/
# https://www.pgmusic.com/tutorial_gm.htm

DRUM_CHANNEL = 9
DRUM_BASS = 36
DRUM_HIGH_TOM = 50
DRUM_LOW_TOM = 45
DRUM_CLOSED_HIHAT = 42
DRUM_CRASH1 = 49
DRUM_SIDE_STICK = 37


class HeartSample(NamedTuple):
    # UNIX timestamp in nanoseconds
    time: int
    rate: float
    rr: tuple[float] = ()


class Player(MidiPlayer):
    def __init__(self, name: str):
        super().__init__(name)
        self.bpm = 0

    def drum(self, note: int, position: float, duration: float, velocity: int = 127):
        beat = 60 / self.bpm
        delay = beat * position
        self.play("note_on", velocity=velocity, note=note, channel=DRUM_CHANNEL, delay_sec=delay)
        self.play("note_off", note=note, channel=DRUM_CHANNEL, delay_sec=delay + beat * duration)

    def note(self, note: int, position: float, duration: float, velocity: int = 127):
        beat = 60 / self.bpm
        delay = beat * position
        self.play("note_on", velocity=velocity, note=note, channel=0, delay_sec=delay)
        self.play("note_off", note=note, channel=0, delay_sec=delay + beat * duration)

    def bank_program_select(self, channel: int, bank: int, program: int, position: int = 0):
        # https://www.sweetwater.com/sweetcare/articles/6-what-msb-lsb-refer-for-changing-banks-andprograms/
        beat = 60 / self.bpm
        delay = beat * position
        self.play("control_change", channel=channel, control=0, value=bank >> 8, delay_sec=delay)
        self.play("control_change", channel=channel, control=32, value=bank & 0xff, delay_sec=delay)
        self.play("program_change", channel=channel, program=program, delay_sec=delay)


class Heart:
    def __init__(self, socket: str):
        self.socket = socket
        self.last_sample: HeartSample | None = None
        self.last_window: deque[float] = deque(maxlen=10)
        self.improvised_delta: float = 0
        self.shutting_down: bool = False
        self.state: str = "coast"

    async def read_socket(self):
        # Read heart beats from https://www.enricozini.org/blog/2023/debian/monitoring-a-heart-rate-monitor/
        reader, writer = await asyncio.open_unix_connection(self.socket)

        # Skip the initial line with recent heartbeat history
        initial = json.loads(await reader.readline())
        for sample in (HeartSample(*s) for s in initial["last"]):
            self.last_window.append(sample.rate)

        while not self.shutting_down and (line := await reader.readline()):
            self.last_sample = HeartSample(*json.loads(line))
            self.on_sample()

    def on_sample(self):
        # print("SAMPLE", self.last_sample)
        if len(self.last_window) > 5:
            # TODO: linear regression instead, then compute divergence from
            # around intercept/slope predicted trend?
            mean = statistics.mean(self.last_window)
            variance = statistics.variance(self.last_window)
            if self.last_sample.rate > mean + variance:
                self.improvised_delta = self.last_sample.rate - mean - variance
            elif self.last_sample.rate < mean - variance:
                self.improvised_delta = -(mean - variance - self.last_sample.rate)
            else:
                self.improvised_delta = 0.0
            # print("Improvised delta:", self.improvised_delta)
        self.last_window.append(self.last_sample.rate)

        if self.improvised_delta > 2:
            self.state = "excite"
        elif self.improvised_delta > 0.5:
            self.state = "climb"
        elif self.improvised_delta < -0.5:
            self.state = "fall"
        else:
            self.state = "coast"


class App:
    def __init__(self, args: argparse.Namespace):
        self.args = args
        self.player: MidiPlayer
        self.heart = Heart(self.args.socket)
        self.shutting_down: bool = False
        self.beat_number: int = 0

    def shutdown(self):
        self.shutting_down = True
        self.heart.shutting_down = True

    async def composer(self):
        while not self.shutting_down:
            if self.heart.last_sample is None:
                await asyncio.sleep(0.2)
                continue
            self.beat_number += 1

            self.beat()

            await asyncio.sleep(60 / self.player.bpm)

        if self.stop_notes():
            await asyncio.sleep(60 / self.player.bpm)

    def beat(self):
        """
        Generate a beat and send it to the player
        """
        raise NotImplementedError()

    def stop_notes(self) -> bool:
        return False

    async def amain(self):
        await asyncio.gather(self.heart.read_socket(), self.composer())

    def aio_thread(self):
        asyncio.run(self.amain())

    def main(self):
        with Player("MIDIStim") as player:
            self.player = player
            aio_thread = threading.Thread(target=self.aio_thread, name="aio")
            aio_thread.start()
            try:
                while True:
                    cmd = input("> ")
                    if cmd.startswith("q"):
                        break
            except (EOFError, KeyboardInterrupt):
                pass
            finally:
                print("Shutting down...")
                self.shutdown()
                aio_thread.join()


class AudibleDrums(App):
    def beat(self):
        self.player.bpm = self.heart.last_sample.rate
        match self.heart.state:
            case "excite":
                self.player.drum(DRUM_LOW_TOM, 0, 1/4)
                self.player.drum(DRUM_CRASH1, 1/2, 1/4)
            case "climb":
                self.player.drum(DRUM_LOW_TOM, 0, 1/4)
                self.player.drum(DRUM_CLOSED_HIHAT, 1/2, 1/4)
            case "coast":
                self.player.drum(DRUM_SIDE_STICK, 0, 1/4, velocity=64)
            case "fall":
                self.player.drum(DRUM_LOW_TOM, 0, 1/4)
            case _:
                raise ValueError(f"unknown state {self.heart.state}")


class OnOff(App):
    def __init__(self, *args, **kw):
        super().__init__(*args, **kw)
        self.silence_until_beat: int = 0

    def beat(self):
        self.player.bpm = 60
        # self.player.bpm = self.heart.last_sample.rate
        print(self.heart.state)
        if self.silence_until_beat > self.beat_number:
            print("silenced")
            return
        match self.heart.state:
            case "excite":
                self.player.play("note_off", note=64, channel=0)
                self.silence_until_beat = self.beat_number + 4
            case "climb":
                self.player.note(64, 0, 7/8)
            case "coast":
                self.player.note(64, 0, 3/4)
            case "fall":
                self.player.note(64, 0, 2/4)

        # self.player.bank_program_select(0, 8, 80)

    def stop_notes(self) -> bool:
        self.player.play("note_off", note=64, channel=0)  # , delay_sec=60 / self.player.bpm / 2)
        return True


def main():
    parser = argparse.ArgumentParser(description="Generate a drum pattern based on heart beat")
    parser.add_argument("socket", action="store", help="path to the socket to use to read heart beats")
    args = parser.parse_args()

    # app = AudibleDrums(args)
    app = OnOff(args)
    app.main()


if __name__ == "__main__":
    sys.exit(main())
