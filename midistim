#!/usr/bin/python3

import argparse
import asyncio
import sys
from typing import NamedTuple, Type

import pyeep.app
from pyeep.generative import (DRUM_CHANNEL, DRUM_CLOSED_HIHAT, DRUM_CRASH1,
                              DRUM_LOW_TOM, DRUM_SIDE_STICK, GenerativeScore)
from pyeep.jackmidi import MidiPlayer
from stim.heart.improvised import Excitement

# See:
# https://soundprogramming.net/file-formats/general-midi-instrument-list/
# https://www.pgmusic.com/tutorial_gm.htm


class HeartSample(NamedTuple):
    # UNIX timestamp in nanoseconds
    time: int
    rate: float
    rr: tuple[float] = ()


class HeartGenerativeScore(GenerativeScore):
    def __init__(self, *, player: MidiPlayer, heart: Excitement, bpm: int = 60, **kw):
        super().__init__(player=player, bpm=bpm)
        self.heart = heart


class App(pyeep.app.JackApp):
    def __init__(self, args: argparse.Namespace):
        super().__init__(args)
        self.player = self.add_jack_component(MidiPlayer)
        self.heart = Excitement(quiet=False)
        self.score: GenerativeScore | None = None

    def shutdown(self):
        super().shutdown()
        self.heart.shutdown()

    def set_score(self, score_cls: Type[GenerativeScore]):
        if self.score is not None:
            self.score.stop()
        self.score = score_cls(player=self.player, heart=self.heart)

    async def composer(self):
        while not self.shutting_down:
            if self.score is None or self.heart.last_sample is None:
                await asyncio.sleep(0.2)
                continue

            self.score.beat()

            await asyncio.sleep(60 / self.score.bpm)

        if self.score.stop():
            await asyncio.sleep(60 / self.score.bpm)

    async def aio_main(self):
        # await asyncio.gather(self.heart.read_socket(), self.composer())
        await asyncio.gather(self.heart.read_socket(self.args.socket), self.composer())

    def ui_main(self):
        try:
            while not self.shutting_down:
                cmd = input("> ")
                if cmd.startswith("q"):
                    break
        except EOFError:
            pass

    def main(self, score_cls: Type[GenerativeScore]):
        self.set_score(score_cls)
        super().main()


class AudibleDrums(HeartGenerativeScore):
    def __init__(self, *args, **kw):
        super().__init__(*args, **kw)
        self.channel = DRUM_CHANNEL

    def beat(self):
        super().beat()
        self.player.bpm = self.heart.last_sample.rate
        # print(self.heart.state)
        match self.heart.state:
            case "excite":
                self.drum(DRUM_LOW_TOM, 0, 1/4)
                self.drum(DRUM_CRASH1, 1/2, 1/4)
            case "climb":
                self.drum(DRUM_LOW_TOM, 0, 1/4)
                self.drum(DRUM_CLOSED_HIHAT, 1/2, 1/4)
            case "coast":
                self.drum(DRUM_LOW_TOM, 0, 1/4)
            case "fall":
                self.drum(DRUM_SIDE_STICK, 0, 1/4, velocity=64)
            case _:
                raise ValueError(f"unknown state {self.heart.state}")


class OnOff(HeartGenerativeScore):
    def __init__(self, *args, **kw):
        super().__init__(*args, **kw)
        self.silence_until_beat: int = 0
        self.channel = 10

    def beat(self):
        super().beat()
        self.player.bpm = 60
        # self.player.bpm = self.heart.last_sample.rate
        # print(self.heart.state)
        if self.silence_until_beat > self.beat_number:
            print("silenced")
            return
        match self.heart.state:
            case "excite":
                self.player.play("note_off", note=64, channel=self.channel)
                self.silence_until_beat = self.beat_number + 4
            case "climb":
                # self.player.play("note_on", note=64, channel=0, velocity=127)
                self.note(64, 0, 7/8)
            case "coast":
                self.note(64, 0, 1/8)
                self.note(64, 2/8, 1/8)
                self.note(64, 4/8, 1/8)
                self.note(64, 6/8, 1/8)
            case "fall":
                self.note(64, 0, 1/4)

        self.bank_program_select(8, 80)

    def stop(self) -> bool:
        self.player.play("note_off", note=64, channel=self.channel)  # , delay_sec=60 / self.player.bpm / 2)
        return True


def main():
    parser = App.argparser("MIDIStim", "Generate a drum pattern based on heart beat")
    parser.add_argument("socket", action="store", help="path to the socket to use to read heart beats")
    parser.add_argument("--drums", action="store_true",
                        help="play a drum loop")
    args = parser.parse_args()

    if args.drums:
        score_cls = AudibleDrums
    else:
        score_cls = OnOff

    with App(args) as app:
        app.main(score_cls)


if __name__ == "__main__":
    sys.exit(main())
