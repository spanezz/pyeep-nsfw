#!/usr/bin/python3

# From https://github.com/hbldh/bleak/tree/develop/examples: enable_notifications.py
# Useful links:
# https://wiki.st.com/stm32mcu/wiki/Connectivity:STM32WB_HeartRate

import argparse
import asyncio
import functools
import logging
import sys
import threading

import numpy

import buttplug
import pyeep.gtk
import pyeep.jack
from pyeep import midisynth
from pyeep.app import Message, Shutdown
from pyeep.gtk import Gtk
from stim import toy

# from stim.lovense_gtk import LovenseCommandLogView


log = logging.getLogger(__name__)


class VibeMixin:
    def get_freq(self):
        return self.note / 69 * 0.7

    def get_attenuation(self, frame_time: int, frames: int) -> numpy.ndarray:
        res = super().get_attenuation(frame_time, frames)
        if (t := self.instrument.transpose):
            return numpy.clip(res + (t / 8192), 0, 1)
        else:
            return res


class OnOff(midisynth.Note):
    def synth(self, frame_time: int, frames: int) -> numpy.ndarray:
        if self.last_note is None:
            return numpy.zeros(frames, dtype=self.dtype)
        value = self.last_note.velocity / 127 + self.instrument.transpose / 8192
        if value > 1:
            value = 1
        elif value < 0:
            value = 0
        return numpy.full(frames, value, dtype=self.dtype)


class SlowSine(VibeMixin, midisynth.Sine):
    pass


class SlowSaw(VibeMixin, midisynth.Sine):
    pass


class SynthMessage(Message):
    def __init__(
            self, *,
            toy_bank: "ToyBank",
            frame_time: int,
            frames: int,
            **kwargs):
        super().__init__(**kwargs)
        self.toy_bank = toy_bank
        self.frame_time = frame_time
        self.frames = frames

    @functools.cached_property
    def data(self):
        return self.toy_bank.instruments.generate(self.frame_time, self.frames)


class ToyBank:
    def __init__(
            self,
            synth: "ToySynth",
            first_channel: int,
            actuator: buttplug.client.client.Actuator):
        self.synth = synth
        self.actuator = actuator
        self.instruments = midisynth.Instruments(
                in_samplerate=synth.samplerate,
                out_samplerate=synth.out_samplerate,
                dtype=numpy.float32)
        self.instruments.set(first_channel + 0, OnOff)
        self.instruments.set(first_channel + 1, SlowSine)
        self.instruments.set(first_channel + 2, SlowSaw)
        self.dst_frame = 0
        self.last_output_frame_time: int | None = None
        self.nchannels = len(self.instruments.instruments)

    def on_process(self, frames: int):
        out_last_frame_time = self.instruments.out_last_frame_time
        if self.last_output_frame_time is None or out_last_frame_time < self.last_output_frame_time:
            self.last_output_frame_time = out_last_frame_time - 1

        if self.last_output_frame_time < out_last_frame_time:
            self.synth.send(SynthMessage(
                dst="toys_player",
                toy_bank=self,
                frame_time=self.last_output_frame_time,
                frames=out_last_frame_time - self.last_output_frame_time))
            self.last_output_frame_time = out_last_frame_time


class ToySynth(midisynth.MidiSynth):
    def __init__(self, **kwargs):
        kwargs.setdefault("out_samplerate", 20)
        super().__init__(**kwargs)
        self.toy_banks: set[ToyBank] = set()
        self.toy_banks_lock = threading.Lock()
        self.first_free_channel = 0

    def receive(self, msg: Message):
        match msg:
            case toy.NewDevice():
                with self.toy_banks_lock:
                    for a in msg.dev.actuators:
                        new_bank = ToyBank(self, self.first_free_channel, actuator=a)
                        self.first_free_channel += new_bank.nchannels
                        self.toy_banks.add(new_bank)
                        self.add_instrument_bank(new_bank.instruments)

    def on_process(self, frames: int):
        super().on_process(frames)
        with self.toy_banks_lock:
            for bank in self.toy_banks:
                bank.on_process(frames)


class ToysPlayer(pyeep.aio.AIOComponent):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.players: dict[buttplug.client.client.Actuator, toy.ToyPlayer] = {}

    async def run(self):
        async with asyncio.TaskGroup() as tg:
            while True:
                msg = await self.next_message(timeout=0.2)

                match msg:
                    case Shutdown():
                        for player in self.players.values():
                            player.shutdown()
                        break
                    case SynthMessage():
                        actuator = msg.toy_bank.actuator
                        if (player := self.players.get(actuator)) is None:
                            player = toy.ToyPlayer(actuator)
                            self.players[actuator] = player
                            tg.create_task(player.play_pattern())
                        for value in msg.data:
                            value = float(value)
                            if not player.pattern_queue or player.pattern_queue[-1] != value:
                                player.pattern_queue.append(value)


class MidiSynthLogView(pyeep.gtk.GtkComponent, pyeep.gtk.LogView):
    def __init__(self, max_lines: int = 10, **kwargs):
        pyeep.gtk.GtkComponent.__init__(self, **kwargs)
        pyeep.gtk.LogView.__init__(self, max_lines)

    def receive(self, msg: Message):
        match msg:
            case midisynth.MidiProcessed:
                for msg in msg.messages:
                    self.append(str(msg))


class ToyView(Gtk.Box):
    def __init__(self, dev: buttplug.client.client.Device, toys_view: "ToysView"):
        super().__init__(orientation=Gtk.Orientation.VERTICAL)
        self.dev = dev
        self.toys_view = toys_view
        self.label_name = Gtk.Label(label=dev.name)
        self.pack_start(self.label_name, False, False, 0)

        for actuator in dev.actuators:
            self.power = Gtk.Scale.new_with_range(
                    orientation=Gtk.Orientation.HORIZONTAL,
                    min=0,
                    max=100,
                    step=5)
            self.power.set_digits(2)
            self.power.set_draw_value(False)
            for mark in (25, 50, 75):
                self.power.add_mark(
                    value=mark,
                    position=Gtk.PositionType.BOTTOM,
                    markup=None
                )
            self.pack_start(self.power, False, False, 0)

            self.power.connect("value_changed", self.on_power, actuator)

    def on_power(self, adj, actuator):
        val = round(adj.get_value())
        self.toys_view.send(toy.SetPower(actuator=actuator, dst="toys", power=val / 100.0))


class ToysView(pyeep.gtk.GtkComponent, Gtk.Box):
    def __init__(self, **kwargs):
        pyeep.gtk.GtkComponent.__init__(self, **kwargs)
        Gtk.Box.__init__(self)

    def receive(self, msg: toy.Message):
        match msg:
            case toy.NewDevice():
                tv = ToyView(msg.dev, self)
                self.pack_start(tv, True, True, 0)
                self.show_all()


class App(pyeep.jack.JackApp, pyeep.gtk.GtkApp, pyeep.aio.AIOApp):
    def __init__(self, args: argparse.Namespace):
        super().__init__(args, title=args.name)
        self.add_component(toy.Toys, client_name=args.name, iface=args.iface)
        self.add_component(ToysPlayer, name="toys_player")
        self.add_component(ToySynth, midi_snoop=True)

        toys_view = self.add_component(ToysView)
        self.vbox.pack_start(toys_view, True, True, 0)

        log_midi = self.add_component(MidiSynthLogView)
        self.vbox.pack_start(log_midi, True, True, 0)

        # first_channel = 0
        # for path in (Path(p) for p in self.args.toys):
        #     if self.args.mock_toy:
        #         toy = lovense.MockLovense(conf=path)
        #     else:
        #         toy = lovense.RealLovense(conf=path)
        #     self.toys.append(toy)
        #     synth = self.add_jack_component(LovenseSynth, toy=toy, first_channel=first_channel, inport=midi_inport)
        #     midi_inport = synth.inport
        #     self.synths.append(synth)

        #     title = f"{path.stem} ch{first_channel}â€¦{first_channel + 3}"
        #     frame = Gtk.Frame.new(title)
        #     hbox.pack_start(frame, True, True, 0)

        #     vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        #     frame.add(vbox)

        #     log_toy = LovenseCommandLogView()
        #     log_toy.attach(toy)
        #     vbox.pack_start(log_toy, True, True, 0)

        #     first_channel += 3


def main():
    parser = App.argparser("Toy MIDI Synth", "Drive a toys as a MIDI instrument")
    parser.add_argument("-i", "--iface", metavar="address", action="store", default="ws://127.0.0.1:12345",
                        help="Intiface Engine address to connect to")
    args = parser.parse_args()

    with App(args) as app:
        app.main()


if __name__ == "__main__":
    sys.exit(main())
