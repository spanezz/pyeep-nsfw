#!/usr/bin/python3

# From https://github.com/hbldh/bleak/tree/develop/examples: enable_notifications.py
# Useful links:
# https://wiki.st.com/stm32mcu/wiki/Connectivity:STM32WB_HeartRate

import argparse
import asyncio
import logging
# import signal
import sys

import pyeep.app
from pyeep import midisynth
from stim.lovense import Lovense

log = logging.getLogger(__name__)

BATTERY_LEVEL_UUID = "00002a19-0000-1000-8000-00805f9b34fb"
MAC = "D9:7E:F0:C7:A9:A5"


class LovenseSynth(midisynth.MidiSynth):
    def __init__(self, loop, lovense: Lovense):
        super().__init__("Lovense")
        self.loop = loop
        self.lovense = lovense

        self.src_frame = self.client.frame_time
        self.dst_frame = 0

        self.min_frame_bundle: int = 2048
        self.current_frame_bundle_time: int | None = None
        self.current_frame_bundle: int = 0

        # Duration of each pattern queue element in nanoseconds
        # (this needs to be proportional to the capacity of the device to handle commands)
        # self.frame_nsecs: int = 50_000_000
        # for i in range(20):
        #     self.pattern_queue.append(i)
        # for i in range(5):
        #     self.pattern_queue.append(20)
        # for i in range(20, 0, -1):
        #     self.pattern_queue.append(i)
        # self.pattern_queue.append(0)

    def on_process(self, frames: int):
        super().on_process(frames)

        if self.current_frame_bundle_time is None:
            self.current_frame_bundle_time = self.client.last_frame_time
        self.current_frame_bundle += frames

        if self.current_frame_bundle > self.min_frame_bundle:
            self.loop.call_soon_threadsafe(self.on_midi_data, self.current_frame_bundle_time, self.current_frame_bundle)
            self.current_frame_bundle = 0
            self.current_frame_bundle_time = self.client.last_frame_time

    def on_midi_data(self, frame_time: int, frames: int):
        data = self.generate_resampled(frame_time, frames, self.lovense.sample_rate)
        for val in data:
            self.lovense.pattern_queue.append(int(round(val * 20)))


class App(pyeep.app.App):
    def __init__(self, args: argparse.Namespace):
        super().__init__(args)
        self.lovense: Lovense | None = None

    def shutdown(self):
        super().shutdown()
        if self.lovense:
            self.lovense.shutting_down = True

    async def aio_main(self):
        # async with HeartRateMonitor(addr=MAC) as monitor:
        # characteristic 45440002-0023-4bd4-bbd5-a6920e4c5653 Unknown 12 (0 descriptors)
        # characteristic 45440003-0023-4bd4-bbd5-a6920e4c5653 Unknown 14 (1 descriptors)
        async with Lovense(
                addr=MAC,
                read_uuid="45440003-0023-4bd4-bbd5-a6920e4c5653",
                write_uuid="45440002-0023-4bd4-bbd5-a6920e4c5653") as lovense:
            # print(f"Battery level: {await dev.read_battery_level()}%")
            await lovense.start()
            self.lovense = lovense
            await self.lovense.send_command("Vibrate:0;")

            with LovenseSynth(asyncio.get_event_loop(), self.lovense):
                # await asyncio.gather(
                #     # command_loop(dev, receiver),
                #     dev.play_pattern(),
                # )
                await self.lovense.play_pattern()

    def ui_main(self):
        try:
            while True:
                cmd = input("> ")
                if cmd.startswith("q"):
                    break
        except EOFError:
            pass


def main():
    parser = App.argparser("Drive a Lovense toy as a MIDI instrument")
    args = parser.parse_args()

    with App(args) as app:
        app.main()


if __name__ == "__main__":
    sys.exit(main())
