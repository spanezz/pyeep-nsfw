#!/usr/bin/python3

# From https://github.com/hbldh/bleak/tree/develop/examples: enable_notifications.py
# Useful links:
# https://wiki.st.com/stm32mcu/wiki/Connectivity:STM32WB_HeartRate

import argparse
import asyncio
import logging
# import signal
import sys

from pyeep import midisynth
from stim.lovense import Lovense

try:
    import coloredlogs
    HAVE_COLOREDLOGS = True
except ModuleNotFoundError:
    HAVE_COLOREDLOGS = False


log = logging.getLogger(__name__)

BATTERY_LEVEL_UUID = "00002a19-0000-1000-8000-00805f9b34fb"
MAC = "D9:7E:F0:C7:A9:A5"


class LovenseSynth(midisynth.MidiSynth):
    def __init__(self, loop, lovense: Lovense):
        super().__init__("Lovense")
        self.loop = loop
        self.lovense = lovense

        self.src_frame = self.client.frame_time
        self.dst_frame = 0

        self.min_frame_bundle: int = 2048
        self.current_frame_bundle_time: int | None = None
        self.current_frame_bundle: int = 0

        # Duration of each pattern queue element in nanoseconds
        # (this needs to be proportional to the capacity of the device to handle commands)
        # self.frame_nsecs: int = 50_000_000
        # for i in range(20):
        #     self.pattern_queue.append(i)
        # for i in range(5):
        #     self.pattern_queue.append(20)
        # for i in range(20, 0, -1):
        #     self.pattern_queue.append(i)
        # self.pattern_queue.append(0)

    def on_process(self, frames: int):
        super().on_process(frames)

        if self.current_frame_bundle_time is None:
            self.current_frame_bundle_time = self.client.last_frame_time
        self.current_frame_bundle += frames

        if self.current_frame_bundle > self.min_frame_bundle:
            self.loop.call_soon_threadsafe(self.on_midi_data, self.current_frame_bundle_time, self.current_frame_bundle)
            self.current_frame_bundle = 0
            self.current_frame_bundle_time = self.client.last_frame_time

    def on_midi_data(self, frame_time: int, frames: int):
        data = self.generate_resampled(frame_time, frames, self.lovense.sample_rate)
        for val in data:
            self.lovense.pattern_queue.append(int(round(val * 20)))

# async def ugly_read_stdin() -> str:
#     loop = asyncio.get_event_loop()
#     return await loop.run_in_executor(None, lambda: input("command> "))
#
#
# async def command_loop(dev, receiver):
#     while True:
#         events, frames = receiver.get_events(receiver.samplerate * 0.1)
#         for evt in events:
#             match evt.msg.type:
#                 case "note_on":
#                     speed = int(round(evt.msg.velocity / 127 * 20))
#                     await dev.send_command(f"Vibrate:{speed};")
#                 case "note_off":
#                     await dev.send_command("Vibrate:0;")
#             print(repr(evt))
#         asyncio.sleep(0.1 - frames / receiver.samplerate)

    # for i in range(0, 20):
    #     await dev.send_command(f"Vibrate:{i};")
    #     await asyncio.sleep(0.05)
    # await dev.send_command("Vibrate:0;")
    # while True:
    #     cmd = (await ugly_read_stdin()).strip()
    #     await dev.client.write_gatt_char(dev.write_uuid, cmd.encode())


async def aio_main(address: str):
    log.info("starting scan...")

    # signals = (signal.SIGTERM, signal.SIGINT)

    # async with HeartRateMonitor(addr=MAC) as monitor:
    # characteristic 45440002-0023-4bd4-bbd5-a6920e4c5653 Unknown 12 (0 descriptors)
    # characteristic 45440003-0023-4bd4-bbd5-a6920e4c5653 Unknown 14 (1 descriptors)
    async with Lovense(
            addr=address,
            read_uuid="45440003-0023-4bd4-bbd5-a6920e4c5653",
            write_uuid="45440002-0023-4bd4-bbd5-a6920e4c5653") as dev:
        # print(f"Battery level: {await dev.read_battery_level()}%")
        await dev.start()
        # for s in signals:
        #     asyncio.get_event_loop().add_signal_handler(s, lambda s=s: asyncio.create_task(dev.stop()))
        await dev.send_command("Vibrate:0;")

        with LovenseSynth(asyncio.get_event_loop(), dev):
            # await asyncio.gather(
            #     # command_loop(dev, receiver),
            #     dev.play_pattern(),
            # )
            await dev.play_pattern()


def main():
    parser = argparse.ArgumentParser(description="Drive a Lovense toy")
    parser.add_argument("-v", "--verbose", action="store_true",
                        help="verbose output")
    parser.add_argument("--debug", action="store_true",
                        help="verbose output")
    # parser.add_argument("address", help="device address")

    args = parser.parse_args()

    FORMAT = "%(asctime)-15s %(levelname)s %(name)s %(message)s"
    if args.debug:
        log_level = logging.DEBUG
    elif args.verbose:
        log_level = logging.INFO
    else:
        log_level = logging.WARN

    if coloredlogs is not None:
        coloredlogs.install(level=log_level, fmt=FORMAT)
    else:
        logging.basicConfig(level=log_level, stream=sys.stderr, format=FORMAT)

    # return asyncio.run(aio_main(args.address))
    return asyncio.run(aio_main(MAC))


if __name__ == "__main__":
    sys.exit(main())
