#!/usr/bin/python3

# From https://github.com/hbldh/bleak/tree/develop/examples: enable_notifications.py
# Useful links:
# https://wiki.st.com/stm32mcu/wiki/Connectivity:STM32WB_HeartRate

import argparse
import asyncio
import logging
import queue
import sys

import jack
import mido
import numpy

import pyeep.gtk
from pyeep import midisynth
from stim.lovense import Lovense

log = logging.getLogger(__name__)

BATTERY_LEVEL_UUID = "00002a19-0000-1000-8000-00805f9b34fb"
MAC = "D9:7E:F0:C7:A9:A5"


class SlowSine(midisynth.Sine):
    def __init__(self, *args, **kw):
        super().__init__(*args, **kw)
        self.freq = self.note / 69 * 0.7
        self.factor = self.freq * 2.0 * numpy.pi / self.samplerate


class SlowSaw(midisynth.Sine):
    def __init__(self, *args, **kw):
        super().__init__(*args, **kw)
        self.freq = self.note / 69 * 0.7
        self.factor = self.freq / self.samplerate


class LovenseSynth(midisynth.MidiSynth):
    def __init__(self, client: jack.Client, *, lovense: Lovense):
        super().__init__(client, out_samplerate=lovense.sample_rate)
        self.loop: asyncio.AbstractEventLoop | None = None
        self.lovense = lovense

        self.src_frame = self.client.frame_time
        self.dst_frame = 0
        self.last_output_frame_time: int | None = None

        self.instruments.set(0, midisynth.OnOff)
        self.instruments.set(1, SlowSine)
        self.instruments.set(2, SlowSaw)

    def on_process(self, frames: int):
        super().on_process(frames)

        out_last_frame_time = self.instruments.out_last_frame_time
        if self.last_output_frame_time is None or out_last_frame_time < self.last_output_frame_time:
            self.last_output_frame_time = out_last_frame_time - 1

        if self.last_output_frame_time < out_last_frame_time:
            if self.loop is not None:
                self.loop.call_soon_threadsafe(
                        self.on_midi_data,
                        self.last_output_frame_time,
                        out_last_frame_time - self.last_output_frame_time)
            self.last_output_frame_time = out_last_frame_time

    def on_midi_data(self, frame_time: int, frames: int):
        data = self.instruments.generate(frame_time, frames)
        for val in data:
            value = int(round(abs(val) * 20))
            if not self.lovense.pattern_queue or self.lovense.pattern_queue[-1] != value:
                self.lovense.pattern_queue.append(value)


class LovenseCommandLogView(pyeep.gtk.LogView):
    def __init__(self, max_lines: int = 10):
        super().__init__(max_lines)
        self.queue: queue.Queue[str] = queue.Queue()

    def attach(self, lovense: Lovense):
        lovense.notify_command = self.on_command

    def on_command(self, cmd):
        # Executed in the aio thread
        self.queue.put(cmd)
        pyeep.gtk.GLib.idle_add(self.process_queues)

    def process_queues(self):
        while not self.queue.empty():
            self.append(self.queue.get())
        return False


class MidiSynthLogView(pyeep.gtk.LogView):
    def __init__(self, max_lines: int = 10):
        super().__init__(max_lines)
        self.queue: queue.Queue[list[mido.Message]] = queue.Queue()

    def attach(self, synth: midisynth.MidiSynth):
        synth.midi_snoop = self.on_midi

    def on_midi(self, msgs: list[mido.Message]):
        # Executed in the JACK thread
        self.queue.put(msgs)
        pyeep.gtk.GLib.idle_add(self.process_queues)

    def process_queues(self):
        while not self.queue.empty():
            for msg in self.queue.get():
                self.append(str(msg))
        return False


class App(pyeep.app.JackApp, pyeep.gtk.GtkApp):
    def __init__(self, args: argparse.Namespace):
        super().__init__(args, title=args.name)
        self.lovense = Lovense(
                addr=MAC,
                read_uuid="45440003-0023-4bd4-bbd5-a6920e4c5653",
                write_uuid="45440002-0023-4bd4-bbd5-a6920e4c5653")
        self.synth = self.add_jack_component(LovenseSynth, lovense=self.lovense)

        self.log_midi = MidiSynthLogView()
        self.vbox.pack_start(self.log_midi, True, True, 0)
        self.log_lovense = LovenseCommandLogView()
        self.vbox.pack_start(self.log_lovense, True, True, 0)

    def shutdown(self):
        super().shutdown()
        if self.lovense:
            self.lovense.shutting_down = True

    async def aio_main(self):
        self.synth.loop = asyncio.get_event_loop()
        async with self.lovense:
            # print(f"Battery level: {await dev.read_battery_level()}%")
            self.log_lovense.attach(self.lovense)
            await self.lovense.start()
            await self.lovense.send_command("Vibrate:0;")

            self.log_midi.attach(self.synth)
            await self.lovense.play_pattern()


def main():
    parser = App.argparser("Lovense MIDI Synth", "Drive a Lovense toy as a MIDI instrument")
    args = parser.parse_args()

    with App(args) as app:
        app.main()


if __name__ == "__main__":
    sys.exit(main())
