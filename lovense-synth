#!/usr/bin/python3

# From https://github.com/hbldh/bleak/tree/develop/examples: enable_notifications.py
# Useful links:
# https://wiki.st.com/stm32mcu/wiki/Connectivity:STM32WB_HeartRate

import argparse
import asyncio
import logging
import queue
import sys
from pathlib import Path

import jack
import mido
import numpy

import pyeep.gtk
from pyeep import midisynth
from stim import lovense

log = logging.getLogger(__name__)

BATTERY_LEVEL_UUID = "00002a19-0000-1000-8000-00805f9b34fb"
MAC = "D9:7E:F0:C7:A9:A5"


class SlowSine(midisynth.Sine):
    def get_freq(self):
        return self.note / 69 * 0.7


class SlowSaw(midisynth.Sine):
    def get_freq(self):
        return self.note / 69 * 0.7


class LovenseSynth(midisynth.MidiSynth):
    def __init__(self, client: jack.Client, *, toy: lovense.Lovense):
        super().__init__(client, out_samplerate=toy.sample_rate)
        self.loop: asyncio.AbstractEventLoop | None = None
        self.toy = toy

        self.src_frame = self.client.frame_time
        self.dst_frame = 0
        self.last_output_frame_time: int | None = None

        self.instruments.set(0, midisynth.OnOff)
        self.instruments.set(1, SlowSine)
        self.instruments.set(2, SlowSaw)

    def on_process(self, frames: int):
        super().on_process(frames)

        out_last_frame_time = self.instruments.out_last_frame_time
        if self.last_output_frame_time is None or out_last_frame_time < self.last_output_frame_time:
            self.last_output_frame_time = out_last_frame_time - 1

        if self.last_output_frame_time < out_last_frame_time:
            if self.loop is not None:
                self.loop.call_soon_threadsafe(
                        self.on_midi_data,
                        self.last_output_frame_time,
                        out_last_frame_time - self.last_output_frame_time)
            self.last_output_frame_time = out_last_frame_time

    def on_midi_data(self, frame_time: int, frames: int):
        data = self.instruments.generate(frame_time, frames)
        for val in data:
            value = int(round(abs(val) * 20))
            if not self.toy.pattern_queue or self.toy.pattern_queue[-1] != value:
                self.toy.pattern_queue.append(value)


class LovenseCommandLogView(pyeep.gtk.LogView):
    def __init__(self, max_lines: int = 10):
        super().__init__(max_lines)
        self.queue: queue.Queue[str] = queue.Queue()

    def attach(self, toy: lovense.Lovense):
        toy.notify_command = self.on_command

    def on_command(self, cmd):
        # Executed in the aio thread
        self.queue.put(cmd)
        pyeep.gtk.GLib.idle_add(self.process_queues)

    def process_queues(self):
        while not self.queue.empty():
            self.append(self.queue.get())
        return False


class MidiSynthLogView(pyeep.gtk.LogView):
    def __init__(self, max_lines: int = 10):
        super().__init__(max_lines)
        self.queue: queue.Queue[list[mido.Message]] = queue.Queue()

    def attach(self, synth: midisynth.MidiSynth):
        synth.midi_snoop = self.on_midi

    def on_midi(self, msgs: list[mido.Message]):
        # Executed in the JACK thread
        self.queue.put(msgs)
        pyeep.gtk.GLib.idle_add(self.process_queues)

    def process_queues(self):
        while not self.queue.empty():
            for msg in self.queue.get():
                self.append(str(msg))
        return False


class App(pyeep.app.JackApp, pyeep.gtk.GtkApp):
    def __init__(self, args: argparse.Namespace):
        super().__init__(args, title=args.name)
        if self.args.mock_toy:
            self.toy = lovense.MockLovense(conf=Path(self.args.toy))
        else:
            self.toy = lovense.RealLovense(conf=Path(self.args.toy))
        self.synth = self.add_jack_component(LovenseSynth, toy=self.toy)

        self.log_midi = MidiSynthLogView()
        self.vbox.pack_start(self.log_midi, True, True, 0)
        self.log_toy = LovenseCommandLogView()
        self.vbox.pack_start(self.log_toy, True, True, 0)

    def shutdown(self):
        super().shutdown()
        if self.toy:
            self.toy.shutdown()

    async def aio_main(self):
        self.synth.loop = asyncio.get_event_loop()
        async with self.toy:
            # print(f"Battery level: {await dev.read_battery_level()}%")
            self.log_toy.attach(self.toy)
            await self.toy.start()
            await self.toy.send_command("Vibrate:0;")

            self.log_midi.attach(self.synth)
            await self.toy.play_pattern()


def main():
    parser = App.argparser("Lovense MIDI Synth", "Drive a Lovense toy as a MIDI instrument")
    parser.add_argument("toy", metavar="file.json", action="store",
                        help="toy description to use to connect")
    parser.add_argument("--mock-toy", action="store_true",
                        help="do not really connect to a toy")
    args = parser.parse_args()

    with App(args) as app:
        app.main()


if __name__ == "__main__":
    sys.exit(main())
