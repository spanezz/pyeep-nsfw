#!/usr/bin/python3

# From https://github.com/hbldh/bleak/tree/develop/examples: enable_notifications.py
# Useful links:
# https://wiki.st.com/stm32mcu/wiki/Connectivity:STM32WB_HeartRate

import argparse
import asyncio
import contextlib
import logging
import queue
import sys
from pathlib import Path

import jack
import mido
import numpy

import pyeep.gtk
from pyeep.gtk import Gtk
from pyeep import midisynth
from stim import lovense
from stim.lovense_gtk import LovenseCommandLogView

log = logging.getLogger(__name__)

BATTERY_LEVEL_UUID = "00002a19-0000-1000-8000-00805f9b34fb"
MAC = "D9:7E:F0:C7:A9:A5"


class VibeMixin:
    def get_freq(self):
        return self.note / 69 * 0.7

    def get_attenuation(self, frame_time: int, frames: int) -> numpy.ndarray:
        res = super().get_attenuation(frame_time, frames)
        if (t := self.instrument.transpose):
            return numpy.clip(res + (t / 8192), 0, 1)
        else:
            return res


class OnOff(midisynth.Note):
    def synth(self, frame_time: int, frames: int) -> numpy.ndarray:
        if self.last_note is None:
            return numpy.zeros(frames, dtype=self.dtype)
        value = self.last_note.velocity / 127 + self.instrument.transpose / 8192
        if value > 1:
            value = 1
        elif value < 0:
            value = 0
        return numpy.full(frames, value, dtype=self.dtype)


class SlowSine(VibeMixin, midisynth.Sine):
    pass


class SlowSaw(VibeMixin, midisynth.Sine):
    pass


class LovenseSynth(midisynth.MidiSynth):
    def __init__(self, client: jack.Client, *, toy: lovense.Lovense, first_channel: int = 0, **kwargs):
        super().__init__(client, out_samplerate=toy.sample_rate, **kwargs)
        self.loop: asyncio.AbstractEventLoop | None = None
        self.toy = toy

        self.src_frame = self.client.frame_time
        self.dst_frame = 0
        self.last_output_frame_time: int | None = None

        self.instruments.set(first_channel + 0, OnOff)
        self.instruments.set(first_channel + 1, SlowSine)
        self.instruments.set(first_channel + 2, SlowSaw)

    def on_process(self, frames: int):
        super().on_process(frames)

        out_last_frame_time = self.instruments.out_last_frame_time
        if self.last_output_frame_time is None or out_last_frame_time < self.last_output_frame_time:
            self.last_output_frame_time = out_last_frame_time - 1

        if self.last_output_frame_time < out_last_frame_time:
            if self.loop is not None:
                self.loop.call_soon_threadsafe(
                        self.on_midi_data,
                        self.last_output_frame_time,
                        out_last_frame_time - self.last_output_frame_time)
            self.last_output_frame_time = out_last_frame_time

    def on_midi_data(self, frame_time: int, frames: int):
        data = self.instruments.generate(frame_time, frames)
        for val in data:
            value = int(round(abs(val) * 20))
            if not self.toy.pattern_queue or self.toy.pattern_queue[-1] != value:
                self.toy.pattern_queue.append(value)


class MidiSynthLogView(pyeep.gtk.LogView):
    def __init__(self, max_lines: int = 10):
        super().__init__(max_lines)
        self.queue: queue.Queue[list[mido.Message]] = queue.Queue()

    def attach(self, synth: midisynth.MidiSynth):
        synth.midi_snoop = self.on_midi

    def on_midi(self, msgs: list[mido.Message]):
        # Executed in the JACK thread
        self.queue.put(msgs)
        pyeep.gtk.GLib.idle_add(self.process_queues)

    def process_queues(self):
        while not self.queue.empty():
            for msg in self.queue.get():
                self.append(str(msg))
        return False


class App(pyeep.app.JackApp, pyeep.gtk.GtkApp):
    def __init__(self, args: argparse.Namespace):
        super().__init__(args, title=args.name)
        self.toys: list[lovense.Lovense] = []
        self.synths: list[LovenseSynth] = []

        hbox = Gtk.Box()
        self.vbox.pack_start(hbox, True, True, 0)

        first_channel = 0
        midi_inport: jack.OwnMidiPort | None = None
        for path in (Path(p) for p in self.args.toys):
            if self.args.mock_toy:
                toy = lovense.MockLovense(conf=path)
            else:
                toy = lovense.RealLovense(conf=path)
            self.toys.append(toy)
            synth = self.add_jack_component(LovenseSynth, toy=toy, first_channel=first_channel, inport=midi_inport)
            midi_inport = synth.inport
            self.synths.append(synth)

            title = f"{path.stem} ch{first_channel}â€¦{first_channel + 3}"
            frame = Gtk.Frame.new(title)
            hbox.pack_start(frame, True, True, 0)

            vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
            frame.add(vbox)

            log_midi = MidiSynthLogView()
            log_midi.attach(synth)

            vbox.pack_start(log_midi, True, True, 0)
            log_toy = LovenseCommandLogView()
            log_toy.attach(toy)
            vbox.pack_start(log_toy, True, True, 0)

            first_channel += 3

    def shutdown(self):
        super().shutdown()
        for toy in self.toys:
            toy.shutdown()

    async def aio_main(self):
        for synth in self.synths:
            synth.loop = asyncio.get_event_loop()

        stack = contextlib.AsyncExitStack()
        async with stack:
            for toy in self.toys:
                await stack.enter_async_context(toy)
            await toy.start()
            await toy.send_command("Vibrate:0;")

            await asyncio.gather(*(toy.play_pattern() for toy in self.toys))


def main():
    parser = App.argparser("Lovense MIDI Synth", "Drive a Lovense toy as a MIDI instrument")
    parser.add_argument("toys", metavar="file.json", nargs="+", action="store",
                        help="toy description(s) to use to connect")
    parser.add_argument("--mock-toy", action="store_true",
                        help="do not really connect to a toy")
    args = parser.parse_args()

    with App(args) as app:
        app.main()


if __name__ == "__main__":
    sys.exit(main())
