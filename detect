#!/usr/bin/python3

import argparse
import asyncio
import json
import sys
from collections import deque
from typing import NamedTuple, Optional

import numpy
import scipy.stats


class HeartSample(NamedTuple):
    # UNIX timestamp in nanoseconds
    time: int
    rate: float
    rr: tuple[float] = ()


class Climb:
    def __init__(self, samples: list[HeartSample], slope: float):
        self.samples = list(samples)
        self.min_slope: float = slope
        self.max_slope: float = slope
        self.last_slope: float = slope
        self.min_rate: float = min(s.rate for s in samples)
        self.max_rate: float = max(s.rate for s in samples)

    @property
    def duration(self) -> float:
        return (self.samples[-1].time - self.samples[0].time) / 1_000_000_000

    def extend(self, samples: list[HeartSample], slope: float):
        new_samples = [s for s in samples if s.time > self.samples[-1].time]
        self.samples.extend(new_samples)
        for s in new_samples:
            if s.rate < self.min_rate:
                self.min_rate = s.rate
            if s.rate > self.max_rate:
                self.max_rate = s.rate
        if slope < self.min_slope:
            self.min_slope = slope
        if slope > self.max_slope:
            self.max_slope = slope
        self.last_slope = slope


class Window:
    def __init__(self, name: str, width_seconds: float, slope_threshold: float):
        self.name = name
        self.width_seconds = width_seconds
        # Minimum value for tracking slopes
        self.slope_threshold = slope_threshold
        self.climbs: list[Climb] = []
        self.current_climb: Optional[Climb] = None
        self.last_slope: float = 0.0

    def sample(self, samples: list[HeartSample]):
        last_time = samples[-1].time
        threshold = last_time - self.width_seconds * 1_000_000_000
        window_samples = [s for s in samples if s.time >= threshold]
        data = numpy.array([
            [(s.time - last_time) / 1_000_000_000 for s in window_samples],
            [s.rate for s in window_samples]])
        reg = scipy.stats.linregress(data)
        if reg.slope > self.slope_threshold:
            if self.current_climb is None:
                self.current_climb = Climb(window_samples, reg.slope)
            else:
                self.current_climb.extend(window_samples, reg.slope)
        else:
            if self.current_climb and self.current_climb.duration > 3.0:
                self.climbs.append(self.current_climb)
            self.current_climb = None
        self.last_slope = reg.slope

    def summary_char(self) -> str:
        if self.current_climb is None:
            return "-"
        elif self.current_climb.last_slope > 0.3:
            return "*"
        else:
            return "+"


class Detector:
    def __init__(self, socket_name: str) -> None:
        super().__init__()
        self.heartbeat_socket = socket_name
        self.history: deque[HeartSample] = deque(maxlen=20)
        self.windows = [
            Window("15s", 15, slope_threshold=0.1),
            Window("10s", 10, slope_threshold=0.1),
            Window("05s", 5, slope_threshold=0.1),
        ]

    def check_history(self):
        samples = list(self.history)
        desc = ""
        for win in self.windows:
            win.sample(samples)
            desc += win.summary_char()

        # long_samples = data[:, data[0, :] > -15]
        cur_rate = samples[-1].rate

        if self.windows[0].climbs:
            last_climb = self.windows[0].climbs[-1]
            if cur_rate >= last_climb.max_rate:
                desc += "!"

        # TODO: detect when the slopes are maximum and store the samples, to
        # keep a reference of the span of the last climb(s)

        # TODO: when increasing, detect when the beat is going above the
        # average or the span of the last climb

        print("History", [f"{s.rate:3.0f}" for s in self.history], end=" ")
        slopes = ", ".join(f"{w.name}: {w.last_slope:+.04f}" for w in self.windows)
        print(f"{slopes}: {desc}")
        sys.stdout.flush()
        # return
        # samplings = {
        #     "last20": last20,
        #     "last10": last20[-10:],
        #     "last05": last20[-5:],
        # }
        # slopes = {}

    async def monitor_heartbeat(self):
        reader, writer = await asyncio.open_unix_connection(self.heartbeat_socket)
        initial = json.loads(await reader.readline())
        for sample in (HeartSample(*s) for s in initial["last"]):
            self.history.append(sample)
        self.check_history()

        while (line := await reader.readline()):
            sample = HeartSample(*json.loads(line))
            self.history.append(sample)
            self.check_history()

    async def loop(self):
        await self.monitor_heartbeat()


async def amain(detector: Detector):
    await detector.loop()


def main():
    # TODO: allow to use a function for intensity
    # TODO: implement a slow start

    parser = argparse.ArgumentParser(description="Tone pattern generator")
    parser.add_argument("--heart", metavar="socket", action="store",
                        help="UNIX socket to use to listen for heartbeat")
    args = parser.parse_args()

    detector = Detector(args.heart)

    try:
        asyncio.run(amain(detector))
    except KeyboardInterrupt:
        print("Shutting down...")
    finally:
        print("Cleanup...")


if __name__ == "__main__":
    sys.exit(main())
