#!/usr/bin/python3

import argparse
import asyncio
import json
import sys
from collections import deque
from typing import NamedTuple, Optional

import numpy
import scipy.stats


class HeartSample(NamedTuple):
    # UNIX timestamp in nanoseconds
    time: int
    rate: float
    rr: tuple[float] = ()


class Detector:
    def __init__(self, socket_name: str) -> None:
        super().__init__()
        self.heartbeat_socket = socket_name
        self.history: deque[HeartSample] = deque(maxlen=20)
        self.rate_min: Optional[float] = None
        self.rate_max: Optional[float] = None

    def update_minmax(self, sample: HeartSample):
        if self.rate_min is None or self.rate_min > sample.rate:
            self.rate_min = sample.rate
        if self.rate_max is None or self.rate_max < sample.rate:
            self.rate_max = sample.rate

    def check_history(self):
        data = numpy.array([
                [(s.time - self.history[-1].time) / 1_000_000_000 for s in self.history],
                [s.rate for s in self.history],
            ])

        samplings = {
            "20s": data[:, data[0, :] > -20],
            "10s": data[:, data[0, :] > -10],
            "05s": data[:, data[0, :] > -5],
        }
        slopes = {}
        for name, samples in samplings.items():
            reg = scipy.stats.linregress(samples)
            slopes[name] = reg.slope

        span = self.rate_max - self.rate_min
        if span == 0:
            mid = 0
            avg = 0
            place = 0
        else:
            mid = (self.rate_min + self.rate_max) / 2
            avg = numpy.average(samplings["05s"][1, :])
            place = (avg - mid) / ((self.rate_max - self.rate_min) / 2)
        desc = f"{place:+.02f} "

        if slopes["20s"] > 0.3:
            desc += "*"
        elif slopes["20s"] > 0.1:
            desc += "+"
        else:
            desc += "-"

        if slopes["10s"] > 0.3:
            desc += "*"
        elif slopes["10s"] > 0.1:
            desc += "+"
        else:
            desc += "-"

        if slopes["05s"] > 0.3:
            desc += "*"
        elif slopes["05s"] > 0.1:
            desc += "+"
        else:
            desc += "-"

        # ST20 = 0.4
        # ST10a = 0.3
        # ST10b = 0.5
        # ST05a = 0.1
        # ST05b = 1.0

        # state = "unknown"
        # if slopes["10s"] > ST10a:
        #     if slopes["05s"] > ST05a:
        #         if slopes["05s"] > ST05b:
        #             state = ".* very close"
        #         else:
        #             state = "++ climbing"
        #     else:
        #         state = "+- cooling"
        # else:
        #     if slopes["05s"] > ST05a:
        #         if slopes["05s"] > ST05b:
        #             state = "-* climbing fast"
        #         else:
        #             state = "-+ getting interested"
        #     else:
        #         state = "-- chill"

        print("History", [f"{s.rate:3.0f}" for s in self.history], end=" ")
        print(f"20s: {slopes['20s']:+.04f}, 10s: {slopes['10s']:+.04f}, 05s: {slopes['05s']:+.04f}: {desc}")
        sys.stdout.flush()
        # return
        # samplings = {
        #     "last20": last20,
        #     "last10": last20[-10:],
        #     "last05": last20[-5:],
        # }
        # slopes = {}

    async def monitor_heartbeat(self):
        reader, writer = await asyncio.open_unix_connection(self.heartbeat_socket)
        initial = json.loads(await reader.readline())
        for sample in (HeartSample(*s) for s in initial["last"]):
            self.history.append(sample)
            self.update_minmax(sample)
        self.check_history()

        while (line := await reader.readline()):
            sample = HeartSample(*json.loads(line))
            self.history.append(sample)
            self.update_minmax(sample)
            self.check_history()

    async def loop(self):
        await self.monitor_heartbeat()


async def amain(detector: Detector):
    await detector.loop()


def main():
    # TODO: allow to use a function for intensity
    # TODO: implement a slow start

    parser = argparse.ArgumentParser(description="Tone pattern generator")
    parser.add_argument("--heart", metavar="socket", action="store",
                        help="UNIX socket to use to listen for heartbeat")
    args = parser.parse_args()

    detector = Detector(args.heart)

    try:
        asyncio.run(amain(detector))
    except KeyboardInterrupt:
        print("Shutting down...")
    finally:
        print("Cleanup...")


if __name__ == "__main__":
    sys.exit(main())
