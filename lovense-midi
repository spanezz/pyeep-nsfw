#!/usr/bin/python3

# From https://github.com/hbldh/bleak/tree/develop/examples: enable_notifications.py
# Useful links:
# https://wiki.st.com/stm32mcu/wiki/Connectivity:STM32WB_HeartRate

import argparse
import asyncio
import logging
import queue
import sys

import mido

import pyeep.gtk
from pyeep import midisynth
from stim.lovense import Lovense

log = logging.getLogger(__name__)

BATTERY_LEVEL_UUID = "00002a19-0000-1000-8000-00805f9b34fb"
MAC = "D9:7E:F0:C7:A9:A5"


class LovenseSynth(midisynth.MidiSynth):
    def __init__(self, loop, lovense: Lovense, name: str):
        super().__init__(name, synth_samplerate=lovense.sample_rate)
        self.loop = loop
        self.lovense = lovense

        self.src_frame = self.client.frame_time
        self.dst_frame = 0
        self.last_output_frame_time: int | None = None

        self.set_instrument(0, midisynth.OnOff)

    def on_process(self, frames: int):
        super().on_process(frames)
        if self.last_output_frame_time is None:
            self.last_output_frame_time = self.synth_last_frame_time - 1

        if self.last_output_frame_time < self.synth_last_frame_time:
            self.loop.call_soon_threadsafe(
                    self.on_midi_data,
                    self.last_output_frame_time,
                    self.synth_last_frame_time - self.last_output_frame_time)
            self.last_output_frame_time = self.synth_last_frame_time

    def on_midi_data(self, frame_time: int, frames: int):
        data = self.generate(frame_time, frames)
        for val in data:
            self.lovense.pattern_queue.append(int(round(val * 20)))


class LovenseCommandLogView(pyeep.gtk.LogView):
    def __init__(self, max_lines: int = 10):
        super().__init__(max_lines)
        self.queue: queue.Queue[str] = queue.Queue()

    def attach(self, lovense: Lovense):
        lovense.notify_command = self.on_command

    def on_command(self, cmd):
        # Executed in the aio thread
        self.queue.put(cmd)
        pyeep.gtk.GLib.idle_add(self.process_queues)

    def process_queues(self):
        while not self.queue.empty():
            self.append(self.queue.get())
        return False


class MidiSynthLogView(pyeep.gtk.LogView):
    def __init__(self, max_lines: int = 10):
        super().__init__(max_lines)
        self.queue: queue.Queue[list[mido.Message]] = queue.Queue()

    def attach(self, synth: midisynth.MidiSynth):
        synth.midi_snoop = self.on_midi

    def on_midi(self, msgs: list[mido.Message]):
        # Executed in the JACK thread
        self.queue.put(msgs)
        pyeep.gtk.GLib.idle_add(self.process_queues)

    def process_queues(self):
        while not self.queue.empty():
            for msg in self.queue.get():
                self.append(str(msg))
        return False


class App(pyeep.gtk.GtkApp):
    def __init__(self, args: argparse.Namespace):
        super().__init__(args, args.name)
        self.lovense: Lovense | None = None

        self.log_midi = MidiSynthLogView()
        self.vbox.pack_start(self.log_midi, True, True, 0)
        self.log_lovense = LovenseCommandLogView()
        self.vbox.pack_start(self.log_lovense, True, True, 0)

    def shutdown(self):
        super().shutdown()
        if self.lovense:
            self.lovense.shutting_down = True

    async def aio_main(self):
        # async with HeartRateMonitor(addr=MAC) as monitor:
        # characteristic 45440002-0023-4bd4-bbd5-a6920e4c5653 Unknown 12 (0 descriptors)
        # characteristic 45440003-0023-4bd4-bbd5-a6920e4c5653 Unknown 14 (1 descriptors)
        async with Lovense(
                addr=MAC,
                read_uuid="45440003-0023-4bd4-bbd5-a6920e4c5653",
                write_uuid="45440002-0023-4bd4-bbd5-a6920e4c5653") as lovense:
            # print(f"Battery level: {await dev.read_battery_level()}%")
            self.log_lovense.attach(lovense)
            await lovense.start()
            self.lovense = lovense
            await self.lovense.send_command("Vibrate:0;")

            with LovenseSynth(asyncio.get_event_loop(), self.lovense, name=self.args.name) as synth:
                # await asyncio.gather(
                #     # command_loop(dev, receiver),
                #     dev.play_pattern(),
                # )
                self.log_midi.attach(synth)
                await self.lovense.play_pattern()


def main():
    parser = App.argparser("Drive a Lovense toy as a MIDI instrument")
    parser.add_argument("--name", action="store", default="Lovense MIDI",
                        help="JACK name to use")
    args = parser.parse_args()

    with App(args) as app:
        app.main()


if __name__ == "__main__":
    sys.exit(main())
