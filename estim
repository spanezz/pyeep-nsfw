#!/usr/bin/python3

import argparse
import asyncio
import json
import math
import random
import sys
import threading
import time
from collections import deque
from typing import Generator, NamedTuple, Optional

import pyaudio

from stim.pattern import (ChaosPulses, Pattern, PatternSequence, Pulses,
                          Silence, Wave)
from stim.player import Player, WaveWriter


class HeartSample(NamedTuple):
    # UNIX timestamp in nanoseconds
    time: int
    rate: float
    rr: tuple[float] = ()


class Stim(Player, threading.Thread):
    def __init__(self) -> None:
        super().__init__()
        self.audio = pyaudio.PyAudio()
        self.stream: Optional[pyaudio.Stream] = None
        self.shutting_down = False
        self.heartbeat_socket: Optional[str] = None
        self.heart_min: Optional[float] = None
        self.heart_max: Optional[float] = None
        self.heart_last: Optional[float] = None

    async def monitor_heartbeat(self):
        if self.heartbeat_socket is None:
            return
        reader, writer = await asyncio.open_unix_connection(self.heartbeat_socket)
        status = json.loads(await reader.readline())
        self.heart_min = status["min"]
        self.heart_max = status["max"]
        self.heart_last = HeartSample(*status["last"][-1]).rate
        while (line := await reader.readline()):
            sample = HeartSample(*json.loads(line))
            if self.heart_min is None or sample.rate < self.heart_min:
                self.heart_min = sample.rate
            if self.heart_max is None or sample.rate > self.heart_max:
                self.heart_max = sample.rate
            self.heart_last = sample.rate

    async def wait_for_patterns(self):
        while not all(c.ended for c in self.channels):
            await asyncio.sleep(0.2)

    async def loop(self):
        self.start()
        await asyncio.gather(self.monitor_heartbeat(), self.wait_for_patterns())

    def shutdown(self):
        print("shutting down")
        self.shutting_down = True
        if self.stream:
            while self.stream.is_active():
                time.sleep(0.1)
            self.stream.stop_stream()
            self.stream.close()
        self.join()

        self.audio.terminate()

    def _stream_callback(self, in_data, frame_count: int, time_info, status) -> tuple[bytes, int]:
        if self.shutting_down:
            return bytes(), pyaudio.paComplete
        return self.get_samples(frame_count).tobytes(), pyaudio.paContinue

    def run(self):
        # for paFloat32 sample values must be in range [-1.0, 1.0]
        self.stream = self.audio.open(
                format=pyaudio.paFloat32,
                channels=len(self.channels),
                rate=self.sample_rate,
                output=True,
                # See https://stackoverflow.com/questions/31391766/pyaudio-outputs-slow-crackling-garbled-audio
                frames_per_buffer=4096,
                stream_callback=self._stream_callback)


class PulseWaveEscalateBase(PatternSequence):
    PULSE_VOLUME = 0.9
    WAVE_VOLUME = 1
    # MIN_DURATION = 0
    MIN_DURATION = 20
    # START = 1
    START = 20

    def duration_pattern(self) -> Generator[float, None, None]:
        yield from range(self.START, 20)
        for i in range(20, 30):
            yield i
            yield i
        while True:
            yield 30

    def freq_pattern(self) -> Generator[float, None, None]:
        while True:
            yield random.choice([1000, 2000, 5000])


class PulseWaveEscalate(PulseWaveEscalateBase):
    def __init__(self):
        super().__init__("pulse wave escalate")

    def patterns(self) -> Generator[Pattern, None, None]:
        for i, f in zip(self.duration_pattern(), self.freq_pattern()):
            yield Pulses(count=i * 2, duration=0.1, freq=f, volume=self.PULSE_VOLUME, gap=5.0/100.0)
            yield Wave(volume=self.WAVE_VOLUME, duration=self.MIN_DURATION + i / 2, freq=f)
            yield Silence(duration=5.0/100.0)


class PulseWaveEscalateChaotic(PulseWaveEscalateBase):
    FREQ = 1000

    def __init__(self):
        super().__init__("pulse wave escalate with chaotic pulses")

    def patterns(self) -> Generator[Pattern, None, None]:
        for i, f in zip(self.duration_pattern(), self.freq_pattern()):
            yield ChaosPulses(count=i * 2, duration=(0.1, 0.3), freq=(200, 5000), volume=(0.7, 1, 1), gap=5.0/100.0)
            yield Wave(volume=self.WAVE_VOLUME, duration=self.MIN_DURATION + i / 2, freq=self.FREQ)
            yield Silence(duration=5.0/100.0)


class PulseWaveEscalate2(PulseWaveEscalateBase):
    FREQ = 1000
    PULSE_VOLUME = 1.0

    def __init__(self):
        super().__init__("pulse wave escalate 2")

    def patterns(self) -> Generator[Pattern, None, None]:
        for i in self.duration_pattern():
            yield Pulses(count=i * 2, duration=0.6, freq=self.FREQ, volume=self.PULSE_VOLUME, gap=10.0/100.0)
            yield Wave(volume=self.WAVE_VOLUME, duration=i, freq=self.FREQ)
            yield Silence(duration=5.0/100.0)


class VolumeSwing(PatternSequence):
    def __init__(self):
        super().__init__("frequency swing")

    def patterns(self) -> Generator[Pattern, None, None]:
        while True:
            for volume in range(50, 100, 5):
                yield Wave(volume=volume / 100.0, duration=0.1, freq=220)
            yield Wave(volume=1, duration=5, freq=220)
            for volume in range(100, 50, -5):
                yield Wave(volume=volume / 100.0, duration=0.1, freq=220)
            yield Wave(volume=0.5, duration=2, freq=220)


class FrequencyDifference(PatternSequence):
    def __init__(self):
        super().__init__("frequency swing")

    def patterns(self) -> Generator[Pattern, None, None]:
        while True:
            # yield Wave(volume=1.0, duration=1, freq=200)
            yield Wave(volume=1.0, duration=1, freq=1000)


class Caress(PatternSequence):
    FREQ = 1000

    def __init__(self):
        super().__init__("caress")

    def patterns(self) -> Generator[Pattern, None, None]:
        yield Wave(volume=0.3, duration=0.5, freq=self.FREQ)
        peak_size = 1
        while True:
            for i in range(60, 100):
                yield Wave(volume=i / 100.0, duration=i / 1000.0, freq=self.FREQ)
            yield Wave(volume=1, duration=peak_size, freq=self.FREQ)
            peak_size = min(peak_size + 1, 10)
            for i in range(100, 60, -3):
                yield Wave(volume=i / 100.0, duration=i / 1000.0, freq=self.FREQ)


class Calibrate(PatternSequence):
    FREQ = 1000.0

    def __init__(self):
        super().__init__("calibration tune")

    def patterns(self) -> Generator[Pattern, None, None]:
        while True:
            yield Wave(volume=1.0, duration=10, freq=self.FREQ)


class FrequencySwing(PatternSequence):
    def __init__(self):
        super().__init__("frequency swing")

    def patterns(self) -> Generator[Pattern, None, None]:
        for freq in range(50, 1000, 100):
            yield Wave(volume=1.0, duration=1, freq=freq)


class RandomPulseWave(PatternSequence):
    def __init__(self):
        super().__init__("random")

    def patterns(self) -> Generator[Pattern, None, None]:
        import random
        while True:
            yield Pulses(count=random.randrange(2, 20), duration=0.1, freq=200.0, volume=0.9, gap=5.0/100.0)
            yield Wave(volume=1.0, duration=random.randrange(1, 15) / 2.0, freq=220.0)
            yield Silence(duration=5.0/100.0)


class NumberSequencePulseWave(PatternSequence):
    FREQ = 1000

    def __init__(self, number: str):
        super().__init__(f"random {number}")
        self.number = number

    def patterns(self) -> Generator[Pattern, None, None]:
        while True:
            for val in [int(n) for n in self.number]:
                yield Pulses(count=val, duration=0.1, freq=self.FREQ, volume=0.9, gap=5.0/100.0)
                yield Wave(volume=1.0, duration=val, freq=self.FREQ)
                yield Silence(duration=5.0/100.0)


class RandomPauseWave(PatternSequence):
    FREQ = 1000

    def __init__(self):
        super().__init__("wave with random pause")

    def patterns(self) -> Generator[Pattern, None, None]:
        import random
        yield Wave(volume=0.3, duration=0.3, freq=self.FREQ)
        yield Wave(volume=0.6, duration=0.3, freq=self.FREQ)
        while True:
            yield Wave(volume=1.0, duration=random.randrange(1, 10), freq=self.FREQ)
            yield Silence(duration=random.uniform(3.0/10.0, 1))


class HeartBeat(PatternSequence):
    FREQ = 1000

    def __init__(self, stim: Stim):
        super().__init__("sync pulses with heart beat")
        self.stim = stim

    def patterns(self) -> Generator[Pattern, None, None]:
        yield Wave(volume=0.3, duration=0.3, freq=self.FREQ)
        yield Wave(volume=0.6, duration=0.3, freq=self.FREQ)
        while True:
            if self.stim.heart_last is None:
                yield Silence(duration=0.2)
            else:
                pause = 3.0/10.0
                duration = 60.0 / self.stim.heart_last
                yield Wave(volume=1.0, freq=self.FREQ, duration=duration - pause)
                yield Silence(duration=pause)


class HeartBeat1(PatternSequence):
    FREQ = 1000

    def __init__(self, stim: Stim):
        super().__init__("sync pulses with heart beat variation")
        self.stim = stim

    def patterns(self) -> Generator[Pattern, None, None]:
        yield Wave(volume=0.3, duration=0.3, freq=self.FREQ)
        yield Wave(volume=0.6, duration=0.3, freq=self.FREQ)
        window = deque(maxlen=60)
        while True:
            if self.stim.heart_last is None:
                yield Silence(duration=0.2)
            else:
                val_last = self.stim.heart_last
                window.append(val_last)
                val_min = min(window)
                val_max = max(window)
                # val_mid = (val_min + val_max) / 2.0
                # Value between -1 and 1
                if val_min == val_max:
                    val_norm = 0
                else:
                    val_norm = (val_last - val_min) / (val_max - val_min)
                pause = 3.0 / 10.0
                volume = 1.0

                import scipy.stats
                last_samples = list(window)[-5:]
                res = scipy.stats.linregress(list(range(len(last_samples))), last_samples)
                print(last_samples, res.slope)
                if res.slope > 0:
                    duration = 1
                    pause = 0
                elif res.slope == 0:
                    duration = 2
                else:
                    duration = 60.0 / self.stim.heart_last * 2
                    volume = 0.9

                # duration = math.asin(val_norm * 2 - 1) + math.pi / 2 + 1

                # duration = val_norm ** 2 * 2 + 1

                # duration = 3 - val_norm ** 2 * 2.5

                # duration = val_norm ** 2 * 2.5 + 0.5

                # if val_norm < 0.5:
                #     duration = 60.0 / self.stim.heart_last
                # else:
                #     duration = 60.0 / self.stim.heart_last
                #     duration *= ((val_norm + 0.5) * 3) ** 2
                print(f"{val_last=} {val_min=} {val_max=} {val_norm=}")
                yield Wave(volume=volume, freq=self.FREQ, duration=duration - pause)
                if pause:
                    yield Silence(duration=pause)


async def amain(player: Player):
    await player.loop()


def main():
    # TODO: allow to use a function for intensity
    # TODO: implement a slow start

    parser = argparse.ArgumentParser(description="Tone pattern generator")
    parser.add_argument("-o", "--output", action="store", metavar="file.wav",
                        help="write the generated audio to the given file instead of playing it")
    parser.add_argument("-c", "--calibrate", action="store_true",
                        help="play a constant full volume calibration sound")
    parser.add_argument("--heart", metavar="socket", action="store",
                        help="UNIX socket to use to listen for heartbeat")
    args = parser.parse_args()

    if args.output:
        player = WaveWriter(args.output)
    else:
        player = Stim()
        if args.heart:
            player.heartbeat_socket = args.heart

    try:
        if args.calibrate:
            player.start_mono(Calibrate())
        else:
            player.start_mono(HeartBeat1(player))
            # player.start_mono(PulseWaveEscalate())
            # player.start_mono(PulseWaveEscalateChaotic())
            # player.start_stereo(
            #         left=PulseWaveEscalate(),
            #         # left=PulseWaveEscalateChaotic(),
            #         # left=RandomPauseWave(),
            #         # right=RandomPauseWave())
            #         # right=FrequencySwing())
            #         right=PulseWaveEscalateChaotic())
            # player.start_mono(PulseWaveEscalate2())
            # player.start_mono(FrequencySwing())
            # player.start_mono(FrequencyDifference())
            # player.start_mono(Caress())
            # player.start_mono(RandomPulseWave())
            # player.start_mono(RandomPauseWave())
            # player.start_mono(NumberSequencePulseWave("1234124312"))
            # player.start_stereo(left=FrequencySwing(), right=FrequencySwing())
            # player.start_stereo(
            #         left=PulseWaveEscalate(),
            #         right=VolumeSwing(),
            # )

        asyncio.run(amain(player))
        print("AMAIN END")
    except KeyboardInterrupt:
        print("Shutting down...")
    finally:
        print("CLEANUP")
        player.shutdown()


if __name__ == "__main__":
    sys.exit(main())
