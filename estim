#!/usr/bin/python3

import argparse
import io
import random
import sys
import threading
import time
import wave
from typing import Generator, Iterator, Optional

import numpy
import pyaudio


class Pattern:
    """
    Abstract interface for a wave generator
    """
    def __init__(self, description: str):
        self.player: "Player"
        self.channel_name: str
        self.buffer = io.BytesIO()
        self.description = description
        self.is_silence = False
        self._iter_waves: Optional[Iterator[numpy.ndarray]] = None
        self.current_wave: Optional[numpy.ndarray] = None
        self.read_offset: int = 0
        self.ended: bool = False

    def set_player(self, player: "Player", channel_name: str):
        self.player = player
        self.channel_name = channel_name

    def generate(self) -> Generator[numpy.ndarray, None, None]:
        raise NotImplementedError(f"{self.__class__.__name__}.generate not implemented")

    def _next_wave(self) -> bool:
        """
        Move self.current_wave to the next wave, or set self.ended if the
        generator is done.

        Returns True if there is a current wave to be read
        """
        if self._iter_waves is None:
            self._iter_waves = iter(self.generate())
        try:
            self.current_wave = next(self._iter_waves)
            self.read_offset = 0
            return True
        except StopIteration:
            self.ended = True
            return False

    def announce(self):
        if self.is_silence:
            return
        print("ã€œ", self.channel_name, self.description)

    def read(self, nsamples: int) -> numpy.ndarray:
        """
        Return an array of at most `nsamples` samples from this pattern.

        If the pattern terminates before the given number of samples, the
        returned array may be shorter than nsamples
        """
        # Shortcut: wave queue is empty
        if self.ended:
            return numpy.empty(0, dtype=self.player.numpy_type)

        if self.current_wave is None:
            if not self._next_wave():
                return numpy.empty(0, dtype=self.player.numpy_type)

        # Shortcut: first wave has enough data
        if len(self.current_wave) >= self.read_offset + nsamples:
            res = self.current_wave[self.read_offset:self.read_offset + nsamples]
            self.read_offset += nsamples
            return res

        # Incrementally build a samples array
        res = numpy.empty(0, self.player.numpy_type)
        while (size := nsamples - len(res)) > 0:
            if self.ended:
                # No more waves available
                return res
            elif self.read_offset >= len(self.current_wave):
                # Current wave is exausted, skip to the next one
                self._next_wave()
            else:
                # Take from current wave
                chunk = self.current_wave[self.read_offset:self.read_offset + size]
                self.read_offset += len(chunk)
                res = numpy.append(res, chunk)

        return res

    @property
    def data(self):
        return self.buffer.getvalue()

    def silence(self, *, duration: float) -> numpy.ndarray:
        self.player.wave_delta_arcsin = 0
        return numpy.zeros(round(duration * self.player.sample_rate), dtype=self.player.numpy_type)

    def wave(self, *, volume: float = 1.0, duration: float = 1.0, freq: float = 440.0) -> numpy.ndarray:
        if not duration:
            return numpy.empty(0, dtype=self.player.numpy_type)

        samples_count = round(duration * self.player.sample_rate)
        factor = 2.0 * numpy.pi * freq / self.player.sample_rate
        wave = numpy.sin(
                numpy.arange(samples_count, dtype=self.player.numpy_type)
                * factor + self.player.wave_delta_arcsin) * volume
        self.player.wave_delta_arcsin = numpy.arcsin(wave[-1])
        return wave


class Silence(Pattern):
    def __init__(self, *, duration: float = 1.0):
        super().__init__(f"{duration:.2f}s of silence")
        self.is_silence = True
        self.duration = duration

    def generate(self) -> Generator[numpy.ndarray, None, None]:
        yield self.silence(duration=self.duration)


class Wave(Pattern):
    def __init__(
            self, *,
            volume: float = 1.0,
            duration: float = 1.0,
            freq: float = 440.0):
        """
        Wave `duration` seconds long
        """
        super().__init__(f"wave {duration=:.2f}s {volume=} {freq=}")
        self.volume = volume
        self.duration = duration
        self.freq = freq

    def generate(self) -> Generator[numpy.ndarray, None, None]:
        yield self.wave(volume=self.volume, duration=self.duration, freq=self.freq)


class Pulses(Pattern):
    def __init__(
            self, *,
            volume: float = 1.0,
            duration: float = 1.0,
            freq: float = 440.0,
            gap: float = 0.1,
            count: int = 1):
        """
        Train of pulses, each `duration` seconds long, followed by a `gap` with
        the given length in seconds
        """
        super().__init__(f"{count} pulses {duration=:.2f}s {volume=} {freq=} {gap=}s")
        self.volume = volume
        self.duration = duration
        self.freq = freq
        self.gap = gap
        self.count = count

    def generate(self) -> Generator[numpy.ndarray, None, None]:
        for i in range(self.count):
            if i > 0:
                yield self.silence(duration=self.gap)
            yield self.wave(volume=self.volume, duration=self.duration, freq=self.freq)


class ChaosPulses(Pattern):
    def __init__(
            self, *,
            volume: tuple[float, float] = (0.9, 1.0, 1.0),
            duration: tuple[float, float] = (1.0, 1.0),
            freq: tuple[float, float] = [200.0, 5000.0],
            gap: tuple[float, float] = [0.1, 0.1],
            count: int = 1):
        """
        Train of pulses, with duration, volume, frequency and gap randomly
        selected from the given intervals
        """
        super().__init__(f"{count} chaotic pulses {duration=}s {volume=} {freq=} {gap=}s")
        self.volume = volume
        self.duration = duration
        self.freq = freq
        self.gap = gap
        self.count = count

    def generate(self) -> Generator[numpy.ndarray, None, None]:
        for i in range(self.count):
            if i > 0:
                yield self.silence(duration=self.gap)
            yield self.wave(
                    volume=random.triangular(*self.volume),
                    duration=random.uniform(*self.duration),
                    freq=random.uniform(*self.freq))


class PatternSequence(Pattern):
    """
    Pattern that generates a sequence of subpatterns
    """
    def patterns(self) -> Generator[Pattern, None, None]:
        raise NotImplementedError(f"{self.__class__.__name__}.pattern_sequence not implemented")

    def generate(self) -> Generator[numpy.ndarray, None, None]:
        for pattern in self.patterns():
            pattern.set_player(self.player, self.channel_name)
            pattern.announce()
            yield from pattern.generate()


class Player:
    def __init__(self, sample_rate: int = 44100, numpy_type=numpy.float32):
        super().__init__()
        # sampling rate, Hz, must be integer
        self.sample_rate = sample_rate
        self.channels: list[Pattern] = []
        self.numpy_type = numpy_type
        # See https://stackoverflow.com/questions/42192239/remove-control-clicking-sound-using-pyaudio-as-an-oscillator
        # This is used to seamlessly join consecutive waveforms
        self.wave_delta_arcsin: int = 0

    def start_mono(self, pattern: Pattern):
        pattern.set_player(self, "mono")
        pattern.announce()
        self.channels.append(pattern)

    def start_stereo(self, left: Pattern, right: Pattern):
        left.set_player(self, "left")
        left.announce()
        self.channels.append(left)
        right.set_player(self, "right")
        right.announce()
        self.channels.append(right)

    def get_samples(self, frame_count: int) -> numpy.ndarray:
        # See https://stackoverflow.com/questions/5347065/interweaving-two-numpy-arrays
        if len(self.channels) == 1:
            # Shortcut for mono output
            wave = self.channels[0].read(frame_count)
            if wave.size < frame_count:
                # Pad with silence
                wave.resize(frame_count)
            return wave

        # General case for an arbitrary number of channels
        waves = numpy.empty(frame_count * len(self.channels), dtype=self.numpy_type)
        for idx, channel in enumerate(self.channels):
            wave = self.channels[idx].read(frame_count)
            if wave.size < frame_count:
                # Pad with silence
                wave.resize(frame_count)
            waves[idx::len(self.channels)] = wave
        return waves

    def loop(self):
        pass


class Stim(Player, threading.Thread):
    def __init__(self) -> None:
        super().__init__()
        self.audio = pyaudio.PyAudio()

        self.stream: Optional[pyaudio.Stream] = None

        self.shutting_down = False

    def loop(self):
        self.start()
        while not self.channels[0].ended:
            time.sleep(0.1)

    def shutdown(self):
        print("shutting down")
        self.shutting_down = True
        if self.stream:
            while self.stream.is_active():
                time.sleep(0.1)
            self.stream.stop_stream()
            self.stream.close()
        self.join()

        self.audio.terminate()

    def _stream_callback(self, in_data, frame_count: int, time_info, status) -> tuple[bytes, int]:
        if self.shutting_down:
            return bytes(), pyaudio.paComplete
        return self.get_samples(frame_count).tobytes(), pyaudio.paContinue

    def run(self):
        # for paFloat32 sample values must be in range [-1.0, 1.0]
        self.stream = self.audio.open(
                format=pyaudio.paFloat32,
                channels=len(self.channels),
                rate=self.sample_rate,
                output=True,
                # See https://stackoverflow.com/questions/31391766/pyaudio-outputs-slow-crackling-garbled-audio
                frames_per_buffer=4096,
                stream_callback=self._stream_callback)


class WaveWriter(Player):
    def __init__(self, filename: str):
        super().__init__()
        self.wav = wave.open(filename, "wb")

    def loop(self):
        self.wav.setnchannels(len(self.channels))
        self.wav.setsampwidth(1)
        self.wav.setframerate(self.sample_rate)
        while True:
            samples = self.get_samples(self.sample_rate)
            data = (samples * 128 + 128).astype(numpy.int8).tobytes()
            self.wav.writeframesraw(data)
            if all(c.ended for c in self.channels):
                break

    def shutdown(self):
        self.wav.close()


class PulseWaveEscalateBase(PatternSequence):
    PULSE_VOLUME = 0.9
    WAVE_VOLUME = 1
    # MIN_DURATION = 0
    MIN_DURATION = 20
    # START = 1
    START = 20

    def duration_pattern(self) -> Generator[float, None, None]:
        yield from range(self.START, 20)
        for i in range(20, 30):
            yield i
            yield i
        while True:
            yield 30

    def freq_pattern(self) -> Generator[float, None, None]:
        while True:
            yield random.choice([1000, 2000, 5000])


class PulseWaveEscalate(PulseWaveEscalateBase):
    def __init__(self):
        super().__init__("pulse wave escalate")

    def patterns(self) -> Generator[Pattern, None, None]:
        for i, f in zip(self.duration_pattern(), self.freq_pattern()):
            yield Pulses(count=i * 2, duration=0.1, freq=f, volume=self.PULSE_VOLUME, gap=5.0/100.0)
            yield Wave(volume=self.WAVE_VOLUME, duration=self.MIN_DURATION + i / 2, freq=f)
            yield Silence(duration=5.0/100.0)


class PulseWaveEscalateChaotic(PulseWaveEscalateBase):
    FREQ = 1000

    def __init__(self):
        super().__init__("pulse wave escalate with chaotic pulses")

    def patterns(self) -> Generator[Pattern, None, None]:
        for i, f in zip(self.duration_pattern(), self.freq_pattern()):
            yield ChaosPulses(count=i * 2, duration=(0.1, 0.3), freq=(200, 5000), volume=(0.7, 1, 1), gap=5.0/100.0)
            yield Wave(volume=self.WAVE_VOLUME, duration=self.MIN_DURATION + i / 2, freq=self.FREQ)
            yield Silence(duration=5.0/100.0)


class PulseWaveEscalate2(PulseWaveEscalateBase):
    FREQ = 1000
    PULSE_VOLUME = 1.0

    def __init__(self):
        super().__init__("pulse wave escalate 2")

    def patterns(self) -> Generator[Pattern, None, None]:
        for i in self.duration_pattern():
            yield Pulses(count=i * 2, duration=0.6, freq=self.FREQ, volume=self.PULSE_VOLUME, gap=10.0/100.0)
            yield Wave(volume=self.WAVE_VOLUME, duration=i, freq=self.FREQ)
            yield Silence(duration=5.0/100.0)


class VolumeSwing(PatternSequence):
    def __init__(self):
        super().__init__("frequency swing")

    def patterns(self) -> Generator[Pattern, None, None]:
        while True:
            for volume in range(50, 100, 5):
                yield Wave(volume=volume / 100.0, duration=0.1, freq=220)
            yield Wave(volume=1, duration=5, freq=220)
            for volume in range(100, 50, -5):
                yield Wave(volume=volume / 100.0, duration=0.1, freq=220)
            yield Wave(volume=0.5, duration=2, freq=220)


class FrequencyDifference(PatternSequence):
    def __init__(self):
        super().__init__("frequency swing")

    def patterns(self) -> Generator[Pattern, None, None]:
        while True:
            # yield Wave(volume=1.0, duration=1, freq=200)
            yield Wave(volume=1.0, duration=1, freq=1000)


class Caress(PatternSequence):
    FREQ = 1000

    def __init__(self):
        super().__init__("caress")

    def patterns(self) -> Generator[Pattern, None, None]:
        yield Wave(volume=0.3, duration=0.5, freq=self.FREQ)
        peak_size = 1
        while True:
            for i in range(60, 100):
                yield Wave(volume=i / 100.0, duration=i / 1000.0, freq=self.FREQ)
            yield Wave(volume=1, duration=peak_size, freq=self.FREQ)
            peak_size = min(peak_size + 1, 10)
            for i in range(100, 60, -3):
                yield Wave(volume=i / 100.0, duration=i / 1000.0, freq=self.FREQ)


class Calibrate(PatternSequence):
    FREQ = 1000.0

    def __init__(self):
        super().__init__("calibration tune")

    def patterns(self) -> Generator[Pattern, None, None]:
        while True:
            yield Wave(volume=1.0, duration=10, freq=self.FREQ)


class FrequencySwing(PatternSequence):
    def __init__(self):
        super().__init__("frequency swing")

    def patterns(self) -> Generator[Pattern, None, None]:
        for freq in range(50, 1000, 100):
            yield Wave(volume=1.0, duration=1, freq=freq)


class RandomPulseWave(PatternSequence):
    def __init__(self):
        super().__init__("random")

    def patterns(self) -> Generator[Pattern, None, None]:
        import random
        while True:
            yield Pulses(count=random.randrange(2, 20), duration=0.1, freq=200.0, volume=0.9, gap=5.0/100.0)
            yield Wave(volume=1.0, duration=random.randrange(1, 15) / 2.0, freq=220.0)
            yield Silence(duration=5.0/100.0)


class NumberSequencePulseWave(PatternSequence):
    FREQ = 1000

    def __init__(self, number: str):
        super().__init__(f"random {number}")
        self.number = number

    def patterns(self) -> Generator[Pattern, None, None]:
        while True:
            for val in [int(n) for n in self.number]:
                yield Pulses(count=val, duration=0.1, freq=self.FREQ, volume=0.9, gap=5.0/100.0)
                yield Wave(volume=1.0, duration=val, freq=self.FREQ)
                yield Silence(duration=5.0/100.0)


class RandomPauseWave(PatternSequence):
    FREQ = 1000

    def __init__(self):
        super().__init__("wave with random pause")

    def patterns(self) -> Generator[Pattern, None, None]:
        import random
        yield Wave(volume=0.3, duration=0.3, freq=self.FREQ)
        yield Wave(volume=0.6, duration=0.3, freq=self.FREQ)
        while True:
            yield Wave(volume=1.0, duration=random.randrange(1, 10), freq=self.FREQ)
            yield Silence(duration=random.uniform(3.0/10.0, 1))


def main():
    # TODO: allow to use a function for intensity
    # TODO: implement a slow start

    parser = argparse.ArgumentParser(description="Tone pattern generator")
    parser.add_argument("-o", "--output", action="store", metavar="file.wav",
                        help="write the generated audio to the given file instead of playing it")
    parser.add_argument("-c", "--calibrate", action="store_true",
                        help="play a constant full volume calibration sound")
    args = parser.parse_args()

    if args.output:
        player = WaveWriter(args.output)
    else:
        player = Stim()

    try:
        if args.calibrate:
            player.start_mono(Calibrate())
        else:
            # player.start_mono(PulseWaveEscalate())
            # player.start_mono(PulseWaveEscalateChaotic())
            player.start_stereo(
                    left=PulseWaveEscalate(),
                    # left=PulseWaveEscalateChaotic(),
                    # left=RandomPauseWave(),
                    right=PulseWaveEscalateChaotic())
                    # right=RandomPauseWave())
                    # right=FrequencySwing())
            # player.start_mono(PulseWaveEscalate2())
            # player.start_mono(FrequencySwing())
            # player.start_mono(FrequencyDifference())
            # player.start_mono(Caress())
            # player.start_mono(RandomPulseWave())
            # player.start_mono(RandomPauseWave())
            # player.start_mono(NumberSequencePulseWave("1234124312"))
            # player.start_stereo(left=FrequencySwing(), right=FrequencySwing())
            # player.start_stereo(
            #         left=PulseWaveEscalate(),
            #         right=VolumeSwing(),
            # )
        player.loop()
    except KeyboardInterrupt:
        print("Shutting down...")

    finally:
        player.shutdown()


if __name__ == "__main__":
    sys.exit(main())
