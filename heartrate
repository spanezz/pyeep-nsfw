#!/usr/bin/python3

# From https://github.com/hbldh/bleak/tree/develop/examples: enable_notifications.py
# Useful links:
# https://wiki.st.com/stm32mcu/wiki/Connectivity:STM32WB_HeartRate

import argparse
import asyncio
import logging
import shutil
import signal
import sys
import time
from collections import deque
from typing import NamedTuple

from bleak import BleakClient, BleakScanner
from bleak.backends.characteristic import BleakGATTCharacteristic
from bleak.backends.device import BLEDevice

try:
    import coloredlogs
    HAVE_COLOREDLOGS = True
except ModuleNotFoundError:
    HAVE_COLOREDLOGS = False


log = logging.getLogger(__name__)

MAC = "CD:E3:36:F6:BB:74"
SENSOR_UUID = "00002a37-0000-1000-8000-00805f9b34fb"


class Sample(NamedTuple):
    # UNIX timestamp in nanoseconds
    time: int
    rate: int
    rr: tuple[float] = ()


class Reporter:
    def __init__(self):
        self.columns, self.lines = shutil.get_terminal_size()

    def add(self, sample: Sample):
        self.history.append(sample)


class HeartRateMonitor:
    """
    Monitor a Bluetooth LE heart rate monitor
    """
    def __init__(self, addr: str, sensor_uuid: str = SENSOR_UUID, history_size: int = 256):
        self.addr = addr
        self.sensor_uuid = sensor_uuid
        self.history: deque[Sample] = deque(maxlen=history_size)
        self.device: BLEDevice
        self.client: BleakClient

    async def __aenter__(self):
        log.info("looking for device...")
        device = await BleakScanner.find_device_by_address(self.addr)
        if device is None:
            raise RuntimeError(f"could not find device with address {self.addr}")
        self.device = device

        log.info("connecting to device...")
        self.client = BleakClient(self.device)
        await self.client.__aenter__()
        log.info("Connected")

        await self.client.start_notify(self.sensor_uuid, self.on_heart_rate)

    async def __aexit__(self, exc_type, exc, tb):
        await self.client.stop_notify(self.sensor_uuid)
        self.client.__aexit__(exc_type, exc, tb)

    def print_device_info(self):
        for service in self.client.services:
            print(f"service {service.uuid}")
            for c in service.characteristics:
                print("  characteristic {c.uuid} {c.description} {c.handle} ({len(c.descriptors)} descriptors)")

    def on_heart_rate(self, characteristic: BleakGATTCharacteristic, data: bytearray):
        """
        Decode heart rate information
        """
        # From https://github.com/fg1/BLEHeartRateLogger
        # See https://www.mariam.qa/post/hr-ble/
        # RR intervals are the intervals in milliseconds between heart beats:
        # see https://help.elitehrv.com/article/67-what-are-r-r-intervals
        log.info("%s: %r", characteristic.description, data)

        byte0 = data[0]
        hrv_uint8 = (byte0 & 1) == 0

        # sensor_contact = (byte0 >> 1) & 3
        # if sensor_contact == 2:
        #     res["sensor_contact"] = "No contact detected"
        # elif sensor_contact == 3:
        #     res["sensor_contact"] = "Contact detected"
        # else:
        #     res["sensor_contact"] = "Sensor contact not supported"

        # Energy expended present
        have_ee = ((byte0 >> 3) & 1) == 1

        # RR intervals present
        have_rr = ((byte0 >> 4) & 1) == 1

        if hrv_uint8:
            hr = data[1]
            i = 2
        else:
            hr = (data[2] << 8) | data[1]
            i = 3

        if have_ee:
            # ee = (data[i + 1] << 8) | data[i]
            i += 2

        rr = []
        if have_rr:
            while i < len(data):
                # Note: Need to divide the value by 1024 to get in seconds
                rr_val = (data[i + 1] << 8) | data[i]
                rr.append(rr_val / 1024)
                i += 2

        sample = Sample(time=time.time_ns(), rate=hr, rr=tuple(rr))
        self.history.append(sample)
        self.on_sample(sample)

    def on_sample(self, sample: Sample):
        """
        Override to do something with samples
        """
        print(sample)


async def aio_main():
    log.info("starting scan...")

    def on_sigwinch():
        print("WINCH")

    asyncio.get_event_loop().add_signal_handler(signal.SIGWINCH, on_sigwinch)

    async with HeartRateMonitor(addr=MAC) as monitor:
        try:
            while True:
                await asyncio.sleep(5.0)
        except KeyboardInterrupt:
            pass

    # device = await BleakScanner.find_device_by_address(
    #     MAC, cb=dict(use_bdaddr=False)
    # )
    # if device is None:
    #     log.error("could not find device with address '%s'", MAC)
    #     return

    # log.info("connecting to device...")

    # async with BleakClient(device) as client:
    #     log.info("Connected")

    #     for service in client.services:
    #         log.info("service %s", service.uuid)
    #         for characteristic in service.characteristics:
    #             log.info(
    #                 "  characteristic %r %s %x (%d descriptors)",
    #                 characteristic.uuid, characteristic.description,
    #                 characteristic.handle, len(characteristic.descriptors))

    #     await client.start_notify(SENSOR_UUID, notification_handler)
    #     try:
    #         while True:
    #             await asyncio.sleep(5.0)
    #     except KeyboardInterrupt:
    #         pass
    #     await client.stop_notify(SENSOR_UUID)


def main():
    parser = argparse.ArgumentParser(description="Read TLE heart rate sensor")
    parser.add_argument("-v", "--verbose", action="store_true",
                        help="verbose output")
    parser.add_argument("--debug", action="store_true",
                        help="verbose output")

    args = parser.parse_args()

    FORMAT = "%(asctime)-15s %(levelname)s %(name)s %(message)s"
    if args.debug:
        log_level = logging.DEBUG
    elif args.verbose:
        log_level = logging.INFO
    else:
        log_level = logging.WARN

    if coloredlogs is not None:
        coloredlogs.install(level=log_level, fmt=FORMAT)
    else:
        logging.basicConfig(level=log_level, stream=sys.stderr, format=FORMAT)

    return asyncio.run(aio_main())


if __name__ == "__main__":
    sys.exit(main())
