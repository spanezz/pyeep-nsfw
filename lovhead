#!/usr/bin/python3

# From https://github.com/hbldh/bleak/tree/develop/examples: enable_notifications.py
# Useful links:
# https://wiki.st.com/stm32mcu/wiki/Connectivity:STM32WB_HeartRate
import argparse
import asyncio
import logging
import sys
import threading
import math
from pathlib import Path
from queue import Queue

import numpy
import pylsl

import pyeep.app
from stim.lovense import Lovense


# class Lovense:
#     def __init__(self, *args, **kw):
#         pass
#
#     async def start(self):
#         pass
#
#     async def send_command(self, *args, **kw):
#         pass
#
#     async def __aenter__(self):
#         return self
#
#     async def __aexit__(self, et, ev, etb):
#         return


log = logging.getLogger(__name__)

BATTERY_LEVEL_UUID = "00002a19-0000-1000-8000-00805f9b34fb"
MAC = "D9:7E:F0:C7:A9:A5"


class Headpos(threading.Thread):
    # Sample rate = 52
    def __init__(self, queue: Queue):
        super().__init__()
        self.queue = queue
        self.shutting_down = False

    def shutdown(self):
        self.shutting_down = True

    def run(self):
        log.info("ACC: connecting to stream inlet")
        self.info = pylsl.resolve_stream('type', "ACC")[0]
        self.inlet = pylsl.StreamInlet(self.info)
        log.info("ACC: connected to stream inlet")

        initial: float | None = None

        while not self.shutting_down:
            samples, timestamps = self.inlet.pull_chunk(timeout=1, max_samples=8)
            data = numpy.array(samples, dtype=float)
            x = numpy.mean(data[:, 0])
            y = numpy.mean(data[:, 1])
            z = numpy.mean(data[:, 2])
            a = math.atan(x / math.sqrt(y**2 + z**2)) / (2 * math.pi) * 360
            # a2 = math.atan(y / math.sqrt(x**2 + z**2)) / (2 * math.pi) * 360
            # a3 = 90 - math.atan(z / math.sqrt(x**2 + y**2)) / (2 * math.pi) * 360
            if initial is None:
                initial = a
            else:
                power = max(0, int(round(20 - abs(initial - a) / 2)))
                self.queue.put(power)


class App(pyeep.app.App):
    def __init__(self, args: argparse.Namespace):
        super().__init__(args)
        self.head_queue = Queue()
        self.headpos = Headpos(self.head_queue)
        self.lovense: Lovense | None = None

    def shutdown(self):
        super().shutdown()
        self.headpos.shutdown()
        self.lovense.shutting_down = True

    # def on_heart_sample(self):
    #     now = time.time()
    #     if now < self.silence_until:
    #         self.lovense.pattern_queue.append(self.edging_level)
    #         self.edge_count += 1
    #         print(self.heart.state, "silenced")
    #         return

    #     print(self.heart.state)
    #     match self.heart.state:
    #         case "excite":
    #             self.coast_count = 0
    #             for i in range(int(self.lovense.sample_rate) + self.edge_count):
    #                 self.lovense.pattern_queue.append(20)
    #             self.lovense.pattern_queue.append(self.edging_level)
    #             self.silence_until = now + 4
    #         case "climb":
    #             self.coast_count = 0
    #             self.lovense.pattern_queue.append(15)
    #         case "coast":
    #             self.lovense.pattern_queue.append(min(20, int(round(12 + self.coast_count / 15))))
    #             self.coast_count += 1
    #         case "fall":
    #             self.coast_count = 0
    #             self.lovense.pattern_queue.append(8)
    #         case _:
    #             raise ValueError(f"unknown state {self.heart.state}")

    async def aio_main(self):
        # async with HeartRateMonitor(addr=MAC) as monitor:
        # characteristic 45440002-0023-4bd4-bbd5-a6920e4c5653 Unknown 12 (0 descriptors)
        # characteristic 45440003-0023-4bd4-bbd5-a6920e4c5653 Unknown 14 (1 descriptors)
        async with Lovense(conf=Path(self.args.toy)) as dev:
            # print(f"Battery level: {await dev.read_battery_level()}%")
            await dev.start()
            await dev.send_command("Vibrate:0;")
            self.lovense = dev

            await asyncio.gather(
                # self.heart.read_socket(self.args.socket),
                dev.play_pattern(),
            )

    def ui_main(self):
        self.headpos.start()
        try:
            while not self.shutting_down:
                val = self.head_queue.get()
                print("Power:", val)
                if self.lovense is not None:
                    self.lovense.pattern_queue.append(val)
        except EOFError:
            pass


def main():
    parser = App.argparser("Edging using a Lovense toy and a heart frequency monitor")
    parser.add_argument("toy", metavar="file.json", action="store", help="toy description to use to connect")
    args = parser.parse_args()

    with App(args) as app:
        app.main()


if __name__ == "__main__":
    sys.exit(main())
