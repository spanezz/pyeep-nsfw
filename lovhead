#!/usr/bin/python3

# From https://github.com/hbldh/bleak/tree/develop/examples: enable_notifications.py
# Useful links:
# https://wiki.st.com/stm32mcu/wiki/Connectivity:STM32WB_HeartRate
import argparse
import asyncio
import logging
import sys
import threading
import math
from pathlib import Path
from queue import Queue

import numpy
import pylsl

import pyeep.app
from stim import lovense
from stim.lovense_gtk import LovenseCommandLogView


log = logging.getLogger(__name__)

BATTERY_LEVEL_UUID = "00002a19-0000-1000-8000-00805f9b34fb"
MAC = "D9:7E:F0:C7:A9:A5"


class Head(threading.Thread):
    # Sample rate = 52
    def __init__(self, toy: lovense.Lovense):
        super().__init__()
        self.toy = toy
        self.loop: asyncio.AbstractEventLoop | None = None
        self.shutting_down = False

    def shutdown(self):
        self.loop = None
        self.shutting_down = True

    def run(self):
        log.info("ACC: connecting to stream inlet")
        self.info = pylsl.resolve_stream('type', "ACC")[0]
        self.inlet = pylsl.StreamInlet(self.info)
        log.info("ACC: connected to stream inlet")

        initial: float | None = None

        while not self.shutting_down:
            samples, timestamps = self.inlet.pull_chunk(timeout=1, max_samples=8)
            data = numpy.array(samples, dtype=float)
            x = numpy.mean(data[:, 0])
            y = numpy.mean(data[:, 1])
            z = numpy.mean(data[:, 2])
            a = math.atan(x / math.sqrt(y**2 + z**2)) / math.pi * 180
            # a2 = math.atan(y / math.sqrt(x**2 + z**2)) / (2 * math.pi) * 360
            # a3 = 90 - math.atan(z / math.sqrt(x**2 + y**2)) / (2 * math.pi) * 360
            if initial is None:
                initial = a
            else:
                power = max(0, int(round(20 - abs(initial - a) / 2)))
                if self.loop is not None:
                    self.loop.call_soon_threadsafe(
                            self.on_command, power)

    def on_command(self, power: int):
        if not self.toy.pattern_queue or self.toy.pattern_queue[-1] != power:
            self.toy.pattern_queue.append(power)


class App(pyeep.gtk.GtkApp):
    def __init__(self, args: argparse.Namespace):
        super().__init__(args, title="Lovhead")
        self.head_queue = Queue()
        if self.args.mock_toy:
            self.toy = lovense.MockLovense(conf=Path(self.args.toy))
        else:
            self.toy = lovense.RealLovense(conf=Path(self.args.toy))
        self.head = Head(self.toy)
        self.log_toy = LovenseCommandLogView()
        self.vbox.pack_start(self.log_toy, True, True, 0)

    def shutdown(self):
        super().shutdown()
        self.head.shutdown()
        self.toy.shutdown()

    async def aio_main(self):
        self.head.loop = asyncio.get_event_loop()
        async with self.toy:
            self.log_toy.attach(self.toy)
            await self.toy.start()
            await self.toy.send_command("Vibrate:0;")
            await asyncio.gather(
                self.toy.play_pattern(),
            )

    def ui_main(self):
        self.head.start()
        super().ui_main()


def main():
    parser = App.argparser("Control lovense toys with head movements")
    parser.add_argument("toy", metavar="file.json", action="store", help="toy description to use to connect")
    parser.add_argument("--mock-toy", action="store_true",
                        help="do not really connect to a toy")
    args = parser.parse_args()

    with App(args) as app:
        app.main()


if __name__ == "__main__":
    sys.exit(main())
